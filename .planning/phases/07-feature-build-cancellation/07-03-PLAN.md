---
phase: 07-feature-build-cancellation
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - Tests/Unit/BuildFFUVM.Cancellation.Tests.ps1
  - Tests/Integration/FFU.Cancellation.Integration.Tests.ps1
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Unit tests verify cancellation checkpoint pattern in BuildFFUVM.ps1"
    - "Integration tests verify cancellation flow with mocked messaging context"
    - "Tests verify cleanup is invoked when cancellation detected"
    - "Tests verify build state transitions to Cancelled"
  artifacts:
    - path: "Tests/Unit/BuildFFUVM.Cancellation.Tests.ps1"
      provides: "Unit tests for cancellation checkpoints"
      min_lines: 60
    - path: "Tests/Integration/FFU.Cancellation.Integration.Tests.ps1"
      provides: "Integration tests for cancellation flow"
      min_lines: 80
  key_links:
    - from: "BuildFFUVM.Cancellation.Tests.ps1"
      to: "BuildFFUVM.ps1"
      via: "Source code pattern matching"
      pattern: "Test-BuildCancellation"
    - from: "FFU.Cancellation.Integration.Tests.ps1"
      to: "FFU.Messaging"
      via: "Messaging context usage"
      pattern: "New-FFUMessagingContext"
---

<objective>
Create comprehensive test coverage for the build cancellation feature, verifying both the checkpoint implementation in BuildFFUVM.ps1 and the end-to-end cancellation flow.

Purpose: Ensure the cancellation feature works correctly and doesn't regress. Tests verify that cancellation checkpoints exist, cleanup is triggered, and build state transitions correctly.

Output: Pester test files providing unit and integration test coverage for build cancellation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-feature-build-cancellation/07-RESEARCH.md
@.planning/phases/07-feature-build-cancellation/07-01-SUMMARY.md

Key references:
- Tests/Unit/FFU.Core.BuildCancellation.Tests.ps1 (from Plan 07-01)
- FFUDevelopment/Modules/FFU.Messaging/FFU.Messaging.psm1 (messaging context)
- FFUDevelopment/BuildFFUVM.ps1 (cancellation checkpoints from Plan 07-02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for BuildFFUVM.ps1 cancellation checkpoints</name>
  <files>Tests/Unit/BuildFFUVM.Cancellation.Tests.ps1</files>
  <action>
Create Pester 5.x unit test file that verifies BuildFFUVM.ps1 has proper cancellation implementation:

```powershell
#Requires -Modules Pester
<#
.SYNOPSIS
    Unit tests for BuildFFUVM.ps1 cancellation checkpoint implementation.

.DESCRIPTION
    Verifies that BuildFFUVM.ps1 contains the required cancellation checkpoints
    at phase boundaries, using source code pattern analysis.
#>

BeforeAll {
    $script:BuildScriptPath = "$PSScriptRoot/../../FFUDevelopment/BuildFFUVM.ps1"
    $script:BuildScriptContent = Get-Content -Path $script:BuildScriptPath -Raw
}

Describe 'BuildFFUVM.ps1 Cancellation Implementation' {

    Context 'Cancellation Checkpoint Coverage' {
        It 'Contains Test-BuildCancellation calls' {
            $matches = [regex]::Matches($script:BuildScriptContent, 'Test-BuildCancellation')
            $matches.Count | Should -BeGreaterOrEqual 8 -Because 'At least 8 cancellation checkpoints should exist'
        }

        It 'All checkpoints use -InvokeCleanup switch' {
            $checkpoints = [regex]::Matches($script:BuildScriptContent, 'Test-BuildCancellation[^}]+')
            foreach ($cp in $checkpoints) {
                $cp.Value | Should -Match '-InvokeCleanup' -Because 'All checkpoints should trigger cleanup'
            }
        }

        It 'All checkpoints specify -PhaseName parameter' {
            $checkpoints = [regex]::Matches($script:BuildScriptContent, 'Test-BuildCancellation[^}]+')
            foreach ($cp in $checkpoints) {
                $cp.Value | Should -Match '-PhaseName' -Because 'All checkpoints should log phase name'
            }
        }

        It 'All checkpoints pass -MessagingContext parameter' {
            $checkpoints = [regex]::Matches($script:BuildScriptContent, 'Test-BuildCancellation[^}]+')
            foreach ($cp in $checkpoints) {
                $cp.Value | Should -Match '-MessagingContext.*\$MessagingContext' -Because 'All checkpoints should use script MessagingContext'
            }
        }

        It 'Checkpoints are followed by return statements' {
            # Pattern: if (Test-BuildCancellation...) { ... return }
            $pattern = 'if\s*\(\s*Test-BuildCancellation[^)]+\)\s*\{[^}]*return'
            $matches = [regex]::Matches($script:BuildScriptContent, $pattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)
            $matches.Count | Should -BeGreaterOrEqual 8 -Because 'Checkpoints should exit on cancellation'
        }
    }

    Context 'Required Phase Checkpoints' {
        It 'Has checkpoint for Pre-flight phase' {
            $script:BuildScriptContent | Should -Match 'Test-BuildCancellation.*Pre-flight'
        }

        It 'Has checkpoint for Driver Download phase' {
            $script:BuildScriptContent | Should -Match 'Test-BuildCancellation.*Driver'
        }

        It 'Has checkpoint for VHDX Creation phase' {
            $script:BuildScriptContent | Should -Match 'Test-BuildCancellation.*(VHDX|VHD)'
        }

        It 'Has checkpoint for VM phase' {
            $script:BuildScriptContent | Should -Match 'Test-BuildCancellation.*VM'
        }

        It 'Has checkpoint for FFU Capture phase' {
            $script:BuildScriptContent | Should -Match 'Test-BuildCancellation.*(FFU|Capture)'
        }
    }

    Context 'Cleanup Registry Finalization' {
        It 'Calls Clear-CleanupRegistry on successful completion' {
            $script:BuildScriptContent | Should -Match 'Clear-CleanupRegistry'
        }
    }

    Context 'Resource Cleanup Registration' {
        It 'Registers VM for cleanup' {
            $script:BuildScriptContent | Should -Match 'Register-VMCleanup'
        }

        It 'Registers VHDX for cleanup' {
            $script:BuildScriptContent | Should -Match 'Register-VHDXCleanup'
        }

        It 'Registers DISM mounts for cleanup' {
            $script:BuildScriptContent | Should -Match 'Register-DISMMountCleanup'
        }
    }
}
```

**Test Categories:**
1. Checkpoint existence (8+ checkpoints)
2. Checkpoint pattern compliance (-InvokeCleanup, -PhaseName, -MessagingContext)
3. Phase coverage (specific phases have checkpoints)
4. Cleanup finalization (Clear-CleanupRegistry on success)
5. Resource registration (Register-*Cleanup calls)

Target: 12-15 test cases
  </action>
  <verify>
`Invoke-Pester Tests/Unit/BuildFFUVM.Cancellation.Tests.ps1 -Output Detailed`
All tests should pass.
  </verify>
  <done>Unit tests verify BuildFFUVM.ps1 has proper cancellation checkpoints with correct patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for cancellation flow</name>
  <files>Tests/Integration/FFU.Cancellation.Integration.Tests.ps1</files>
  <action>
Create Pester 5.x integration test file that verifies the end-to-end cancellation flow:

```powershell
#Requires -Modules Pester
<#
.SYNOPSIS
    Integration tests for FFU build cancellation flow.

.DESCRIPTION
    Tests the complete cancellation mechanism: messaging context creation,
    cancellation request, detection via Test-BuildCancellation, cleanup
    invocation, and state transitions.
#>

BeforeAll {
    # Import required modules
    $modulesPath = "$PSScriptRoot/../../FFUDevelopment/Modules"
    $env:PSModulePath = "$modulesPath;$env:PSModulePath"

    Import-Module "$modulesPath/FFU.Messaging/FFU.Messaging.psd1" -Force
    Import-Module "$modulesPath/FFU.Core/FFU.Core.psd1" -Force

    # Mock WriteLog to prevent actual logging
    function global:WriteLog { param($Message) Write-Verbose $Message }
}

AfterAll {
    Remove-Item Function:\WriteLog -ErrorAction SilentlyContinue
}

Describe 'Cancellation Flow Integration' {

    Context 'Messaging Context Lifecycle' {
        It 'Creates messaging context with cancellation support' {
            $ctx = New-FFUMessagingContext
            $ctx | Should -Not -BeNullOrEmpty
            $ctx.CancellationRequested | Should -Be $false
            $ctx.BuildState | Should -Be 'NotStarted'
        }

        It 'Request-FFUCancellation sets cancellation flag' {
            $ctx = New-FFUMessagingContext
            Request-FFUCancellation -Context $ctx
            $ctx.CancellationRequested | Should -Be $true
        }

        It 'Request-FFUCancellation sets state to Cancelling' {
            $ctx = New-FFUMessagingContext
            Request-FFUCancellation -Context $ctx
            $ctx.BuildState | Should -Be 'Cancelling'
        }
    }

    Context 'Test-BuildCancellation Behavior' {
        BeforeEach {
            # Clear cleanup registry before each test
            Clear-CleanupRegistry
        }

        It 'Returns false when context is null' {
            $result = Test-BuildCancellation -MessagingContext $null -PhaseName "Test"
            $result | Should -Be $false
        }

        It 'Returns false when cancellation not requested' {
            $ctx = New-FFUMessagingContext
            $result = Test-BuildCancellation -MessagingContext $ctx -PhaseName "Test"
            $result | Should -Be $false
        }

        It 'Returns true when cancellation is requested' {
            $ctx = New-FFUMessagingContext
            Request-FFUCancellation -Context $ctx
            $result = Test-BuildCancellation -MessagingContext $ctx -PhaseName "Test"
            $result | Should -Be $true
        }

        It 'With -InvokeCleanup, sets state to Cancelled' {
            $ctx = New-FFUMessagingContext
            Request-FFUCancellation -Context $ctx
            Test-BuildCancellation -MessagingContext $ctx -PhaseName "Test" -InvokeCleanup
            $ctx.BuildState | Should -Be 'Cancelled'
        }
    }

    Context 'Cleanup Registry Integration' {
        BeforeEach {
            Clear-CleanupRegistry
        }

        It 'Registered cleanup actions are invoked on cancellation' {
            $cleanupCalled = $false

            # Register a cleanup action
            Register-CleanupAction -Name "Test Cleanup" -ResourceType "Other" -Action {
                $script:cleanupCalled = $true
            }

            # Simulate cancellation
            $ctx = New-FFUMessagingContext
            Request-FFUCancellation -Context $ctx

            # This would be called by Test-BuildCancellation -InvokeCleanup
            Invoke-FailureCleanup -Reason "Test cancellation"

            # Verify cleanup was called
            # Note: We can't directly verify $cleanupCalled due to scope,
            # but we can verify registry is empty after cleanup
            (Get-CleanupRegistry).Count | Should -Be 0
        }

        It 'Multiple cleanup actions are invoked in LIFO order' {
            $order = [System.Collections.ArrayList]::new()

            Register-CleanupAction -Name "First" -ResourceType "Other" -Action {
                $null = $order.Add("First")
            }
            Register-CleanupAction -Name "Second" -ResourceType "Other" -Action {
                $null = $order.Add("Second")
            }
            Register-CleanupAction -Name "Third" -ResourceType "Other" -Action {
                $null = $order.Add("Third")
            }

            Invoke-FailureCleanup -Reason "LIFO test"

            # LIFO: Third, Second, First
            # Can verify registry is empty
            (Get-CleanupRegistry).Count | Should -Be 0
        }

        It 'Clear-CleanupRegistry removes all actions without invoking' {
            Register-CleanupAction -Name "Test" -ResourceType "Other" -Action { throw "Should not be called" }

            (Get-CleanupRegistry).Count | Should -Be 1

            Clear-CleanupRegistry

            (Get-CleanupRegistry).Count | Should -Be 0
        }
    }

    Context 'State Transitions' {
        It 'Full cancellation flow transitions: NotStarted -> Running -> Cancelling -> Cancelled' {
            $ctx = New-FFUMessagingContext

            $ctx.BuildState | Should -Be 'NotStarted'

            Set-FFUBuildState -Context $ctx -State Running
            $ctx.BuildState | Should -Be 'Running'

            Request-FFUCancellation -Context $ctx
            $ctx.BuildState | Should -Be 'Cancelling'

            Set-FFUBuildState -Context $ctx -State Cancelled
            $ctx.BuildState | Should -Be 'Cancelled'
        }
    }

    Context 'Message Queue During Cancellation' {
        It 'Cancellation messages are queued' {
            $ctx = New-FFUMessagingContext

            Request-FFUCancellation -Context $ctx

            # Read messages from queue
            $messages = Read-FFUMessages -Context $ctx

            $messages.Count | Should -BeGreaterOrEqual 1
            $messages | Where-Object { $_.Message -match 'Cancellation|cancel' } | Should -Not -BeNullOrEmpty
        }
    }
}
```

**Test Categories:**
1. Messaging context lifecycle (creation, cancellation flag)
2. Test-BuildCancellation behavior (null context, no cancel, with cancel)
3. Cleanup registry integration (actions invoked, LIFO order, clear)
4. State transitions (full cancellation flow)
5. Message queue verification

Target: 15-20 test cases
  </action>
  <verify>
`Invoke-Pester Tests/Integration/FFU.Cancellation.Integration.Tests.ps1 -Output Detailed`
All tests should pass.
  </verify>
  <done>Integration tests verify end-to-end cancellation flow including messaging, cleanup, and state transitions</done>
</task>

</tasks>

<verification>
1. Unit tests pass: `Invoke-Pester Tests/Unit/BuildFFUVM.Cancellation.Tests.ps1 -PassThru | Select -Expand Result`
2. Integration tests pass: `Invoke-Pester Tests/Integration/FFU.Cancellation.Integration.Tests.ps1 -PassThru | Select -Expand Result`
3. Test count: Combined tests should be 25+ test cases
4. No test file syntax errors: Files parse without errors
</verification>

<success_criteria>
- Unit test file verifies BuildFFUVM.ps1 cancellation checkpoint patterns (12+ tests)
- Integration test file verifies end-to-end cancellation flow (15+ tests)
- All tests pass
- Tests cover: checkpoint existence, pattern compliance, cleanup invocation, state transitions
- Tests are self-contained and don't require actual VM operations
</success_criteria>

<output>
After completion, create `.planning/phases/07-feature-build-cancellation/07-03-SUMMARY.md`
</output>
