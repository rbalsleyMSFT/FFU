---
phase: 05-integration-tests-core
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Tests/Integration/FFU.Imaging.Integration.Tests.ps1
autonomous: true

must_haves:
  truths:
    - "Integration tests verify FFU capture workflow logic"
    - "Tests verify VHDX creation and partitioning patterns"
    - "Tests verify New-FFU parameter passing and orchestration"
    - "Mocked tests work without real disk operations"
  artifacts:
    - path: "Tests/Integration/FFU.Imaging.Integration.Tests.ps1"
      provides: "Integration tests for FFU.Imaging module"
      min_tests: 15
  key_links:
    - from: "Tests/Integration/FFU.Imaging.Integration.Tests.ps1"
      to: "FFU.Imaging.psm1"
      via: "Import-Module and function calls"
      pattern: "Import-Module.*FFU\\.Imaging"
---

<objective>
Create integration tests for FFU capture process (TEST-03)

Purpose: Verify FFU creation workflow including VHDX creation, partitioning, image application, and FFU capture. Tests should use mocking for disk operations and DISM cmdlets to avoid requiring actual VHDXs or Windows images.

Output: Tests/Integration/FFU.Imaging.Integration.Tests.ps1 with 15+ tests covering New-ScratchVhdx, partition functions, New-FFU, and capture workflow
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/05-integration-tests-core/05-RESEARCH.md

Key references:
- FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psm1 (imaging functions)
- FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psd1 (exports 21 functions)
- Tests/Unit/FFU.Imaging.Tests.ps1 (existing unit test patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FFU.Imaging integration test file with disk operation stubs</name>
  <files>Tests/Integration/FFU.Imaging.Integration.Tests.ps1</files>
  <action>
Create new test file `Tests/Integration/FFU.Imaging.Integration.Tests.ps1`:

```powershell
#Requires -Version 5.1
#Requires -Modules @{ ModuleName = 'Pester'; ModuleVersion = '5.0.0' }

<#
.SYNOPSIS
    Pester integration tests for FFU.Imaging module

.DESCRIPTION
    Integration tests covering VHDX creation, partitioning, image application,
    and FFU capture workflows. Tests use mocking for disk operations and DISM
    cmdlets to avoid requiring actual VHDXs or Windows images.

.NOTES
    Run all: Invoke-Pester -Path .\Tests\Integration\FFU.Imaging.Integration.Tests.ps1 -Output Detailed
    Coverage: TEST-03 - Integration tests for FFU capture process
#>

BeforeAll {
    # Get paths relative to test file location
    $TestRoot = Split-Path $PSScriptRoot -Parent
    $ProjectRoot = Split-Path $TestRoot -Parent
    $ModulesPath = Join-Path $ProjectRoot 'FFUDevelopment\Modules'
    $ModulePath = Join-Path $ModulesPath 'FFU.Imaging'

    # Add Modules folder to PSModulePath for RequiredModules resolution
    if ($env:PSModulePath -notlike "*$ModulesPath*") {
        $env:PSModulePath = "$ModulesPath;$env:PSModulePath"
    }

    # Create stub functions for Hyper-V and Storage cmdlets if not available
    if (-not (Get-Command New-VHD -ErrorAction SilentlyContinue)) {
        function global:New-VHD { param($Path, $SizeBytes, $Dynamic) }
        function global:Mount-VHD { param($Path, $Passthru) }
        function global:Dismount-VHD { param($Path) }
        function global:Get-VHD { param($Path) }
    }

    if (-not (Get-Command Get-Disk -ErrorAction SilentlyContinue)) {
        function global:Get-Disk { param($Number, $Path) }
        function global:Initialize-Disk { param($Number, $PartitionStyle) }
        function global:Get-Partition { param($DiskNumber, $DriveLetter) }
        function global:New-Partition { param($DiskNumber, $Size, $GptType, $DriveLetter, $UseMaximumSize) }
        function global:Format-Volume { param($DriveLetter, $FileSystem, $NewFileSystemLabel, $Confirm) }
        function global:Get-Volume { param($DriveLetter) }
    }

    # Create stub functions for DISM cmdlets
    if (-not (Get-Command Expand-WindowsImage -ErrorAction SilentlyContinue)) {
        function global:Expand-WindowsImage { param($ImagePath, $Index, $ApplyPath) }
        function global:Add-WindowsDriver { param($Path, $Driver, $Recurse) }
        function global:Mount-WindowsImage { param($Path, $ImagePath, $Index) }
        function global:Dismount-WindowsImage { param($Path, $Save, $Discard) }
        function global:Get-WindowsImage { param($ImagePath) }
        function global:New-WindowsImage { param($CapturePath, $ImagePath, $Name, $CompressionType) }
    }

    # Remove and re-import module
    Get-Module -Name 'FFU.Imaging', 'FFU.Core' | Remove-Module -Force -ErrorAction SilentlyContinue

    # Import FFU.Imaging (will auto-load FFU.Core dependency)
    if (-not (Test-Path "$ModulePath\FFU.Imaging.psd1")) {
        throw "FFU.Imaging module not found at: $ModulePath"
    }
    Import-Module "$ModulePath\FFU.Imaging.psd1" -Force -ErrorAction Stop
}

AfterAll {
    Get-Module -Name 'FFU.Imaging', 'FFU.Core' | Remove-Module -Force -ErrorAction SilentlyContinue
}

# =============================================================================
# New-ScratchVhdx Integration Tests
# =============================================================================

Describe 'New-ScratchVhdx Integration' -Tag 'Integration', 'FFU.Imaging', 'VHDXCreation' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    Context 'VHDX Creation Workflow (Mocked)' {

        BeforeEach {
            # Mock Hyper-V VHDX cmdlets
            Mock New-VHD {
                return [PSCustomObject]@{
                    Path = $Path
                    Size = $SizeBytes
                    VhdFormat = 'VHDX'
                }
            } -ModuleName 'FFU.Imaging'

            Mock Mount-VHD {
                return [PSCustomObject]@{
                    Path = $Path
                    DiskNumber = 1
                }
            } -ModuleName 'FFU.Imaging'

            Mock Get-Disk {
                return [PSCustomObject]@{
                    Number = 1
                    PartitionStyle = 'RAW'
                    Size = 50GB
                    BusType = 'File Backed Virtual'
                }
            } -ModuleName 'FFU.Imaging'

            Mock Initialize-Disk { } -ModuleName 'FFU.Imaging'
            Mock Test-Path { return $true } -ModuleName 'FFU.Imaging'
            Mock New-Item { } -ModuleName 'FFU.Imaging'
        }

        It 'Should create VHDX with specified size' {
            New-ScratchVhdx -FFUDevelopmentPath 'C:\FFUDevelopment' -SizeBytes 50GB

            Should -Invoke New-VHD -ModuleName 'FFU.Imaging' -Times 1 -ParameterFilter {
                $SizeBytes -eq 50GB
            }
        }

        It 'Should mount the created VHDX' {
            New-ScratchVhdx -FFUDevelopmentPath 'C:\FFUDevelopment' -SizeBytes 50GB

            Should -Invoke Mount-VHD -ModuleName 'FFU.Imaging' -Times 1
        }

        It 'Should initialize disk with GPT partition style' {
            New-ScratchVhdx -FFUDevelopmentPath 'C:\FFUDevelopment' -SizeBytes 50GB

            Should -Invoke Initialize-Disk -ModuleName 'FFU.Imaging' -Times 1 -ParameterFilter {
                $PartitionStyle -eq 'GPT'
            }
        }

        It 'Should return disk object for partition creation' {
            $result = New-ScratchVhdx -FFUDevelopmentPath 'C:\FFUDevelopment' -SizeBytes 50GB

            $result | Should -Not -BeNullOrEmpty
        }
    }
}

# =============================================================================
# Partition Functions Integration Tests
# =============================================================================

Describe 'Partition Functions Integration' -Tag 'Integration', 'FFU.Imaging', 'Partitioning' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    Context 'New-SystemPartition (Mocked)' {

        BeforeEach {
            Mock New-Partition {
                return [PSCustomObject]@{
                    DiskNumber = $DiskNumber
                    PartitionNumber = 1
                    Size = $Size
                    DriveLetter = $null
                }
            } -ModuleName 'FFU.Imaging'

            Mock Format-Volume { } -ModuleName 'FFU.Imaging'
            Mock Set-Partition { } -ModuleName 'FFU.Imaging'
            Mock Get-Partition {
                return [PSCustomObject]@{
                    DiskNumber = 1
                    PartitionNumber = 1
                    DriveLetter = 'S'
                }
            } -ModuleName 'FFU.Imaging'
        }

        It 'Should create EFI System Partition with correct GUID' {
            $mockDisk = [PSCustomObject]@{ Number = 1 }

            New-SystemPartition -VhdxDisk $mockDisk

            Should -Invoke New-Partition -ModuleName 'FFU.Imaging' -Times 1 -ParameterFilter {
                $GptType -eq '{c12a7328-f81f-11d2-ba4b-00a0c93ec93b}'
            }
        }

        It 'Should format EFI partition as FAT32' {
            $mockDisk = [PSCustomObject]@{ Number = 1 }

            New-SystemPartition -VhdxDisk $mockDisk

            Should -Invoke Format-Volume -ModuleName 'FFU.Imaging' -ParameterFilter {
                $FileSystem -eq 'FAT32'
            }
        }
    }

    Context 'New-OSPartition (Mocked)' {

        BeforeEach {
            Mock New-Partition {
                return [PSCustomObject]@{
                    DiskNumber = $DiskNumber
                    PartitionNumber = 3
                    DriveLetter = $null
                }
            } -ModuleName 'FFU.Imaging'

            Mock Format-Volume { } -ModuleName 'FFU.Imaging'
            Mock Set-Partition { } -ModuleName 'FFU.Imaging'
            Mock Get-Partition {
                return [PSCustomObject]@{
                    DiskNumber = 1
                    PartitionNumber = 3
                    DriveLetter = 'W'
                }
            } -ModuleName 'FFU.Imaging'

            Mock Expand-WindowsImage { } -ModuleName 'FFU.Imaging'
            Mock Test-WimSourceAccessibility {
                return [PSCustomObject]@{ IsAccessible = $true; AccessiblePath = 'C:\test.wim' }
            } -ModuleName 'FFU.Imaging'
        }

        It 'Should create OS partition using maximum available size' {
            $mockDisk = [PSCustomObject]@{ Number = 1 }

            New-OSPartition -VhdxDisk $mockDisk -WimPath 'C:\test.wim' -WimIndex 1

            Should -Invoke New-Partition -ModuleName 'FFU.Imaging' -Times 1
        }

        It 'Should format OS partition as NTFS' {
            $mockDisk = [PSCustomObject]@{ Number = 1 }

            New-OSPartition -VhdxDisk $mockDisk -WimPath 'C:\test.wim' -WimIndex 1

            Should -Invoke Format-Volume -ModuleName 'FFU.Imaging' -ParameterFilter {
                $FileSystem -eq 'NTFS'
            }
        }

        It 'Should apply Windows image to OS partition' {
            $mockDisk = [PSCustomObject]@{ Number = 1 }

            New-OSPartition -VhdxDisk $mockDisk -WimPath 'C:\test.wim' -WimIndex 1

            Should -Invoke Expand-WindowsImage -ModuleName 'FFU.Imaging' -Times 1
        }
    }
}

# =============================================================================
# New-FFU Integration Tests
# =============================================================================

Describe 'New-FFU Integration' -Tag 'Integration', 'FFU.Imaging', 'FFUCapture' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    Context 'FFU Capture Workflow (Mocked)' {

        BeforeEach {
            # Mock DISM capture command
            Mock DISM { $global:LASTEXITCODE = 0 } -ModuleName 'FFU.Imaging'
            Mock Test-Path { return $true } -ModuleName 'FFU.Imaging'
            Mock Get-ChildItem {
                return @([PSCustomObject]@{ FullName = 'C:\FFU\test.ffu' })
            } -ModuleName 'FFU.Imaging'
        }

        It 'Should have CaptureDrive parameter' {
            $command = Get-Command New-FFU -Module FFU.Imaging
            $command.Parameters['CaptureDrive'] | Should -Not -BeNullOrEmpty
        }

        It 'Should have FFUDevelopmentPath parameter' {
            $command = Get-Command New-FFU -Module FFU.Imaging
            $command.Parameters['FFUDevelopmentPath'] | Should -Not -BeNullOrEmpty
        }

        It 'Should have Optimize parameter' {
            $command = Get-Command New-FFU -Module FFU.Imaging
            $command.Parameters['Optimize'] | Should -Not -BeNullOrEmpty
        }

        It 'Should support HypervisorProvider parameter for VMware' {
            $command = Get-Command New-FFU -Module FFU.Imaging

            # Check if HypervisorProvider parameter exists (added for VMware support)
            $command.Parameters['HypervisorProvider'] | Should -Not -BeNullOrEmpty
        }
    }

    Context 'Capture from VHDX (Direct Mode)' {

        It 'Should support VHDXCapture switch for VHDX-direct mode' {
            $command = Get-Command New-FFU -Module FFU.Imaging
            $param = $command.Parameters['VHDXCapture']

            # VHDXCapture enables direct capture from mounted VHDX without VM boot
            $param | Should -Not -BeNullOrEmpty
        }
    }
}

# =============================================================================
# Dismount-ScratchVhdx Integration Tests
# =============================================================================

Describe 'Dismount-ScratchVhdx Integration' -Tag 'Integration', 'FFU.Imaging', 'VHDXDismount' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    Context 'VHDX Dismount Workflow (Mocked)' {

        BeforeEach {
            Mock Dismount-VHD { } -ModuleName 'FFU.Imaging'
            Mock Get-VHD {
                return [PSCustomObject]@{ Path = $Path; Attached = $true }
            } -ModuleName 'FFU.Imaging'
            Mock Test-Path { return $true } -ModuleName 'FFU.Imaging'
        }

        It 'Should call Dismount-VHD for VHDX files' {
            Dismount-ScratchVhdx -VhdxPath 'C:\FFU\scratch.vhdx'

            Should -Invoke Dismount-VHD -ModuleName 'FFU.Imaging' -Times 1
        }
    }
}

# =============================================================================
# Dismount-ScratchVhd Integration Tests (VMware)
# =============================================================================

Describe 'Dismount-ScratchVhd Integration' -Tag 'Integration', 'FFU.Imaging', 'VHDDismount' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    Context 'VHD Dismount with Volume Flush (PERF-01)' {

        BeforeEach {
            # Mock diskpart command
            Mock diskpart { $global:LASTEXITCODE = 0 } -ModuleName 'FFU.Imaging'
            Mock Test-Path { return $true } -ModuleName 'FFU.Imaging'
            Mock Get-Disk {
                return [PSCustomObject]@{
                    Number = 1
                    BusType = 'File Backed Virtual'
                    Location = 'C:\test.vhd'
                }
            } -ModuleName 'FFU.Imaging'
            Mock Get-Partition {
                return [PSCustomObject]@{ DriveLetter = 'Z' }
            } -ModuleName 'FFU.Imaging'
            Mock Write-VolumeCache { } -ModuleName 'FFU.Imaging'
        }

        It 'Should use Write-VolumeCache for flush when available' {
            # Mock Get-Command to indicate Write-VolumeCache is available
            Mock Get-Command {
                return [PSCustomObject]@{ Name = 'Write-VolumeCache' }
            } -ModuleName 'FFU.Imaging' -ParameterFilter { $Name -eq 'Write-VolumeCache' }

            Dismount-ScratchVhd -VhdPath 'C:\test.vhd'

            Should -Invoke Write-VolumeCache -ModuleName 'FFU.Imaging' -Times 1
        }

        It 'Should NOT have triple-pass flush loop' {
            # Verify PERF-01 optimization is in place
            $moduleContent = Get-Content (Join-Path $ModulePath 'FFU.Imaging.psm1') -Raw

            $moduleContent | Should -Not -Match 'Flush pass .* of 3'
            $moduleContent | Should -Not -Match 'for \(\$flushPass = 1'
        }
    }
}

# =============================================================================
# Expand-FFUPartitionForDrivers Integration Tests (BUG-03)
# =============================================================================

Describe 'Expand-FFUPartitionForDrivers Integration' -Tag 'Integration', 'FFU.Imaging', 'PartitionExpand' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    Context 'Partition Expansion Workflow' {

        It 'Should export Expand-FFUPartitionForDrivers function' {
            Get-Command Expand-FFUPartitionForDrivers -Module FFU.Imaging | Should -Not -BeNullOrEmpty
        }

        It 'Should have DriverPath parameter for calculating size' {
            $command = Get-Command Expand-FFUPartitionForDrivers -Module FFU.Imaging
            $command.Parameters['DriverPath'] | Should -Not -BeNullOrEmpty
        }

        It 'Should have VhdxPath parameter for VHDX expansion' {
            $command = Get-Command Expand-FFUPartitionForDrivers -Module FFU.Imaging
            $command.Parameters['VhdxPath'] | Should -Not -BeNullOrEmpty
        }
    }
}

# =============================================================================
# Get-WindowsVersionInfo Integration Tests
# =============================================================================

Describe 'Get-WindowsVersionInfo Integration' -Tag 'Integration', 'FFU.Imaging', 'VersionInfo' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    It 'Should export Get-WindowsVersionInfo function' {
        Get-Command Get-WindowsVersionInfo -Module FFU.Imaging | Should -Not -BeNullOrEmpty
    }

    It 'Should have MountPath parameter' {
        $command = Get-Command Get-WindowsVersionInfo -Module FFU.Imaging
        $command.Parameters['MountPath'] | Should -Not -BeNullOrEmpty
    }
}

# =============================================================================
# Invoke-FFUOptimizeWithScratchDir Integration Tests
# =============================================================================

Describe 'Invoke-FFUOptimizeWithScratchDir Integration' -Tag 'Integration', 'FFU.Imaging', 'FFUOptimize' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Imaging'
    }

    Context 'FFU Optimization Workflow' {

        It 'Should have FFUFile parameter' {
            $command = Get-Command Invoke-FFUOptimizeWithScratchDir -Module FFU.Imaging
            $command.Parameters['FFUFile'] | Should -Not -BeNullOrEmpty
        }

        It 'Should have DandIEnv parameter for ADK environment' {
            $command = Get-Command Invoke-FFUOptimizeWithScratchDir -Module FFU.Imaging
            $command.Parameters['DandIEnv'] | Should -Not -BeNullOrEmpty
        }

        It 'Should have MaxRetries parameter for reliability' {
            $command = Get-Command Invoke-FFUOptimizeWithScratchDir -Module FFU.Imaging
            $command.Parameters['MaxRetries'] | Should -Not -BeNullOrEmpty
        }
    }
}
```
  </action>
  <verify>
File exists and parses correctly:
```powershell
Test-Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Imaging.Integration.Tests.ps1"
```
  </verify>
  <done>Test file created with disk operation stubs and FFU capture workflow tests</done>
</task>

<task type="auto">
  <name>Task 2: Run and verify imaging integration tests pass</name>
  <files>Tests/Integration/FFU.Imaging.Integration.Tests.ps1</files>
  <action>
Run the tests and verify they pass. If any tests fail due to module structure differences, adjust the tests to match the actual module implementation.

Common adjustments needed:
1. Mock placement (may need InModuleScope)
2. Parameter name corrections
3. Function existence validation

Run:
```powershell
Invoke-Pester -Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Imaging.Integration.Tests.ps1" -Output Detailed
```

If tests fail, examine the failure messages and update the test file to match actual module behavior while still testing the integration patterns.
  </action>
  <verify>
```powershell
$result = Invoke-Pester -Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Imaging.Integration.Tests.ps1" -PassThru
$result.FailedCount -eq 0
```
  </verify>
  <done>All imaging integration tests pass, verifying VHDX creation, partitioning, and FFU capture patterns</done>
</task>

</tasks>

<verification>
1. Test file exists and parses correctly:
   ```powershell
   Test-Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Imaging.Integration.Tests.ps1"
   [System.Management.Automation.Language.Parser]::ParseFile("C:\claude\FFUBuilder\Tests\Integration\FFU.Imaging.Integration.Tests.ps1", [ref]$null, [ref]$null)
   ```

2. Tests run and pass:
   ```powershell
   Invoke-Pester -Path "Tests\Integration\FFU.Imaging.Integration.Tests.ps1" -Output Detailed
   ```

3. Count tests (should be 15+):
   ```powershell
   $result = Invoke-Pester -Path "Tests\Integration\FFU.Imaging.Integration.Tests.ps1" -PassThru
   $result.TotalCount
   ```
</verification>

<success_criteria>
- [ ] Tests/Integration/FFU.Imaging.Integration.Tests.ps1 created
- [ ] Disk operation and DISM stub functions created when cmdlets not available
- [ ] VHDX creation workflow tested with mocked Hyper-V cmdlets
- [ ] Partition functions tested with mocked Storage cmdlets
- [ ] New-FFU and capture workflow tested
- [ ] PERF-01 optimization (Write-VolumeCache) verified
- [ ] BUG-03 partition expansion function tested
- [ ] 15+ tests covering VHDX, partitioning, and FFU capture
- [ ] All tests pass without requiring actual disk operations
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-tests-core/05-03-SUMMARY.md`
</output>
