---
phase: 05-integration-tests-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Tests/Integration/FFU.Drivers.Integration.Tests.ps1
autonomous: true

must_haves:
  truths:
    - "Integration tests verify driver injection workflow"
    - "Tests verify Add-WindowsDriver parameter passing"
    - "Copy-Drivers function tested with mock file operations"
    - "OEM driver functions tested without network calls"
  artifacts:
    - path: "Tests/Integration/FFU.Drivers.Integration.Tests.ps1"
      provides: "Integration tests for FFU.Drivers module"
      min_tests: 12
  key_links:
    - from: "Tests/Integration/FFU.Drivers.Integration.Tests.ps1"
      to: "FFU.Drivers.psm1"
      via: "Import-Module and function calls"
      pattern: "Import-Module.*FFU\\.Drivers"
---

<objective>
Create integration tests for driver injection workflow (TEST-02)

Purpose: Verify driver download, extraction, filtering, and injection operations work correctly. Tests should use mocking for file operations and DISM cmdlets to avoid requiring actual driver files or mounted images.

Output: Tests/Integration/FFU.Drivers.Integration.Tests.ps1 with 12+ tests covering Copy-Drivers, OEM driver functions, and driver injection patterns
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/05-integration-tests-core/05-RESEARCH.md

Key references:
- FFUDevelopment/Modules/FFU.Drivers/FFU.Drivers.psm1 (driver management functions)
- FFUDevelopment/Modules/FFU.Drivers/FFU.Drivers.psd1 (exports 6 functions)
- Tests/Unit/FFU.Drivers.Tests.ps1 (existing unit test patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FFU.Drivers integration test file with DISM stubs</name>
  <files>Tests/Integration/FFU.Drivers.Integration.Tests.ps1</files>
  <action>
Create new test file `Tests/Integration/FFU.Drivers.Integration.Tests.ps1`:

```powershell
#Requires -Version 5.1
#Requires -Modules @{ ModuleName = 'Pester'; ModuleVersion = '5.0.0' }

<#
.SYNOPSIS
    Pester integration tests for FFU.Drivers module

.DESCRIPTION
    Integration tests covering driver download, extraction, and injection workflows.
    Tests use mocking for DISM operations and file system to avoid requiring
    actual driver files or mounted Windows images.

.NOTES
    Run all: Invoke-Pester -Path .\Tests\Integration\FFU.Drivers.Integration.Tests.ps1 -Output Detailed
    Coverage: TEST-02 - Integration tests for driver injection workflow
#>

BeforeAll {
    # Get paths relative to test file location
    $TestRoot = Split-Path $PSScriptRoot -Parent
    $ProjectRoot = Split-Path $TestRoot -Parent
    $ModulesPath = Join-Path $ProjectRoot 'FFUDevelopment\Modules'
    $ModulePath = Join-Path $ModulesPath 'FFU.Drivers'

    # Add Modules folder to PSModulePath for RequiredModules resolution
    if ($env:PSModulePath -notlike "*$ModulesPath*") {
        $env:PSModulePath = "$ModulesPath;$env:PSModulePath"
    }

    # Create stub functions for DISM cmdlets if not available
    if (-not (Get-Command Add-WindowsDriver -ErrorAction SilentlyContinue)) {
        function global:Add-WindowsDriver { param($Path, $Driver, $Recurse, $ForceUnsigned) }
        function global:Mount-WindowsImage { param($Path, $ImagePath, $Index) }
        function global:Dismount-WindowsImage { param($Path, $Save, $Discard) }
        function global:Get-WindowsDriver { param($Path, $Online, $All) }
    }

    # Remove and re-import module
    Get-Module -Name 'FFU.Drivers', 'FFU.Core' | Remove-Module -Force -ErrorAction SilentlyContinue

    # Import FFU.Drivers (will auto-load FFU.Core dependency)
    if (-not (Test-Path "$ModulePath\FFU.Drivers.psd1")) {
        throw "FFU.Drivers module not found at: $ModulePath"
    }
    Import-Module "$ModulePath\FFU.Drivers.psd1" -Force -ErrorAction Stop
}

AfterAll {
    Get-Module -Name 'FFU.Drivers', 'FFU.Core' | Remove-Module -Force -ErrorAction SilentlyContinue
}

# =============================================================================
# Copy-Drivers Integration Tests
# =============================================================================

Describe 'Copy-Drivers Integration' -Tag 'Integration', 'FFU.Drivers', 'DriverCopy' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Drivers'
    }

    Context 'Driver Filtering by Architecture' {

        BeforeEach {
            # Mock Test-Path for source directory
            Mock Test-Path { return $true } -ModuleName 'FFU.Drivers'

            # Mock Get-ChildItem to return INF files with architecture info
            Mock Get-ChildItem {
                return @(
                    [PSCustomObject]@{
                        FullName = 'C:\Drivers\Intel\net\e1000.inf'
                        Name = 'e1000.inf'
                        DirectoryName = 'C:\Drivers\Intel\net'
                    },
                    [PSCustomObject]@{
                        FullName = 'C:\Drivers\Intel\storage\iaahci.inf'
                        Name = 'iaahci.inf'
                        DirectoryName = 'C:\Drivers\Intel\storage'
                    }
                )
            } -ModuleName 'FFU.Drivers'

            # Mock Get-Content for INF file reading
            Mock Get-Content {
                return @(
                    '[Version]',
                    'Signature="$WINDOWS NT$"',
                    'Class=Net',
                    'ClassGuid={4d36e972-e325-11ce-bfc1-08002be10318}',
                    '[Manufacturer]',
                    '%Intel%=Intel,NTamd64'
                )
            } -ModuleName 'FFU.Drivers'

            # Mock Copy-Item
            Mock Copy-Item { } -ModuleName 'FFU.Drivers'
            Mock New-Item { } -ModuleName 'FFU.Drivers'
        }

        It 'Should filter drivers by x64 architecture' {
            Copy-Drivers -Path 'C:\Drivers' -Output 'C:\WinPE\Drivers' -WindowsArch 'x64'

            Should -Invoke Get-ChildItem -ModuleName 'FFU.Drivers' -Times 1
        }

        It 'Should copy matching INF files and directories' {
            Copy-Drivers -Path 'C:\Drivers' -Output 'C:\WinPE\Drivers' -WindowsArch 'x64'

            Should -Invoke Copy-Item -ModuleName 'FFU.Drivers'
        }
    }

    Context 'Driver Class Filtering' {

        BeforeEach {
            Mock Test-Path { return $true } -ModuleName 'FFU.Drivers'
            Mock New-Item { } -ModuleName 'FFU.Drivers'

            # Create mock INF files with different class GUIDs
            Mock Get-ChildItem {
                return @(
                    # Network adapter - should be included for WinPE
                    [PSCustomObject]@{
                        FullName = 'C:\Drivers\net.inf'
                        Name = 'net.inf'
                        DirectoryName = 'C:\Drivers'
                    }
                )
            } -ModuleName 'FFU.Drivers'
        }

        It 'Should include Network Adapter drivers (ClassGUID 4d36e972)' {
            # Network adapter class GUID
            Mock Get-Content {
                return @(
                    '[Version]',
                    'ClassGuid={4d36e972-e325-11ce-bfc1-08002be10318}'
                )
            } -ModuleName 'FFU.Drivers'
            Mock Copy-Item { } -ModuleName 'FFU.Drivers'

            Copy-Drivers -Path 'C:\Drivers' -Output 'C:\WinPE\Drivers' -WindowsArch 'x64'

            # Should copy network drivers
            Should -Invoke Copy-Item -ModuleName 'FFU.Drivers'
        }
    }
}

# =============================================================================
# OEM Driver Functions Integration Tests
# =============================================================================

Describe 'OEM Driver Functions Integration' -Tag 'Integration', 'FFU.Drivers', 'OEMDrivers' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Drivers'
    }

    Context 'Get-MicrosoftDrivers (Mocked Network)' {

        BeforeEach {
            # Mock web request to avoid actual network calls
            Mock Invoke-WebRequest {
                throw "Network call blocked in test"
            } -ModuleName 'FFU.Drivers'

            Mock Invoke-RestMethod {
                throw "Network call blocked in test"
            } -ModuleName 'FFU.Drivers'

            Mock Test-Path { return $false } -ModuleName 'FFU.Drivers'
            Mock New-Item { } -ModuleName 'FFU.Drivers'
        }

        It 'Should require valid Make parameter' {
            $command = Get-Command Get-MicrosoftDrivers -Module FFU.Drivers
            $param = $command.Parameters['Make']

            $param | Should -Not -BeNullOrEmpty
            $param.Attributes | Where-Object { $_ -is [System.Management.Automation.ParameterAttribute] } |
                ForEach-Object { $_.Mandatory | Should -BeTrue }
        }

        It 'Should require valid Model parameter' {
            $command = Get-Command Get-MicrosoftDrivers -Module FFU.Drivers
            $param = $command.Parameters['Model']

            $param | Should -Not -BeNullOrEmpty
            $param.Attributes | Where-Object { $_ -is [System.Management.Automation.ParameterAttribute] } |
                ForEach-Object { $_.Mandatory | Should -BeTrue }
        }
    }

    Context 'Get-DellDrivers (Mocked Network)' {

        BeforeEach {
            Mock Invoke-WebRequest { throw "Network blocked" } -ModuleName 'FFU.Drivers'
            Mock Test-Path { return $false } -ModuleName 'FFU.Drivers'
        }

        It 'Should have WindowsArch parameter with ValidateSet' {
            $command = Get-Command Get-DellDrivers -Module FFU.Drivers
            $param = $command.Parameters['WindowsArch']

            $validateSet = $param.Attributes | Where-Object { $_ -is [System.Management.Automation.ValidateSetAttribute] }
            $validateSet.ValidValues | Should -Contain 'x64'
            $validateSet.ValidValues | Should -Contain 'ARM64'
        }

        It 'Should have isServer parameter for server vs client differentiation' {
            $command = Get-Command Get-DellDrivers -Module FFU.Drivers
            $param = $command.Parameters['isServer']

            $param | Should -Not -BeNullOrEmpty
        }
    }

    Context 'Get-HPDrivers (Mocked Network)' {

        BeforeEach {
            Mock Invoke-WebRequest { throw "Network blocked" } -ModuleName 'FFU.Drivers'
            Mock Test-Path { return $false } -ModuleName 'FFU.Drivers'
        }

        It 'Should have WindowsVersion parameter for HP catalog matching' {
            $command = Get-Command Get-HPDrivers -Module FFU.Drivers
            $param = $command.Parameters['WindowsVersion']

            $param | Should -Not -BeNullOrEmpty
        }
    }

    Context 'Get-LenovoDrivers (Mocked Network)' {

        BeforeEach {
            Mock Invoke-WebRequest { throw "Network blocked" } -ModuleName 'FFU.Drivers'
            Mock Test-Path { return $false } -ModuleName 'FFU.Drivers'
        }

        It 'Should require Headers parameter for API authentication' {
            $command = Get-Command Get-LenovoDrivers -Module FFU.Drivers
            $param = $command.Parameters['Headers']

            $param | Should -Not -BeNullOrEmpty
            $param.Attributes | Where-Object { $_ -is [System.Management.Automation.ParameterAttribute] } |
                ForEach-Object { $_.Mandatory | Should -BeTrue }
        }

        It 'Should require UserAgent parameter' {
            $command = Get-Command Get-LenovoDrivers -Module FFU.Drivers
            $param = $command.Parameters['UserAgent']

            $param | Should -Not -BeNullOrEmpty
        }
    }
}

# =============================================================================
# Driver Injection Pattern Tests
# =============================================================================

Describe 'Driver Injection Patterns' -Tag 'Integration', 'FFU.Drivers', 'DriverInjection' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Drivers'
    }

    Context 'Add-WindowsDriver Integration (Mocked DISM)' {

        It 'Should use Add-WindowsDriver with -Recurse for folder injection' {
            # This tests the expected pattern for driver injection
            # The actual call happens in FFU.Imaging, but we verify the pattern

            Mock Add-WindowsDriver { } -ModuleName 'FFU.Drivers'

            # Verify Add-WindowsDriver exists (even if stub)
            { Get-Command Add-WindowsDriver -ErrorAction Stop } | Should -Not -Throw
        }

        It 'Should have DISM cmdlet stubs available for testing' {
            # Verify we can mock DISM operations
            $commands = @('Add-WindowsDriver', 'Mount-WindowsImage', 'Dismount-WindowsImage')

            foreach ($cmd in $commands) {
                { Get-Command $cmd -ErrorAction Stop } | Should -Not -Throw
            }
        }
    }

    Context 'Driver Extraction Timeout (BUG-04 Regression)' {

        It 'Should have timeout constant defined for driver extraction' {
            # Verify the Dell driver extraction timeout fix is in place
            # Check for DRIVER_EXTRACTION_TIMEOUT_SECONDS in FFU.Constants or FFU.Drivers

            $moduleContent = Get-Content (Join-Path $ModulePath 'FFU.Drivers.psm1') -Raw

            # Should have timeout handling for driver extraction
            $moduleContent | Should -Match 'timeout|WaitForExit|DRIVER_EXTRACTION_TIMEOUT'
        }
    }
}

# =============================================================================
# Get-IntelEthernetDrivers Tests
# =============================================================================

Describe 'Get-IntelEthernetDrivers Integration' -Tag 'Integration', 'FFU.Drivers', 'IntelDrivers' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.Drivers'
    }

    Context 'Intel Driver Download (Mocked)' {

        BeforeEach {
            Mock Invoke-WebRequest { throw "Network blocked" } -ModuleName 'FFU.Drivers'
            Mock Test-Path { return $false } -ModuleName 'FFU.Drivers'
            Mock New-Item { } -ModuleName 'FFU.Drivers'
        }

        It 'Should export Get-IntelEthernetDrivers function' {
            Get-Command Get-IntelEthernetDrivers -Module FFU.Drivers | Should -Not -BeNullOrEmpty
        }

        It 'Should have FFUDevelopmentPath parameter' {
            $command = Get-Command Get-IntelEthernetDrivers -Module FFU.Drivers
            $command.Parameters['FFUDevelopmentPath'] | Should -Not -BeNullOrEmpty
        }
    }
}
```
  </action>
  <verify>
File exists and parses correctly:
```powershell
Test-Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Drivers.Integration.Tests.ps1"
```
  </verify>
  <done>Test file created with DISM stubs and driver workflow tests</done>
</task>

<task type="auto">
  <name>Task 2: Run and verify driver integration tests pass</name>
  <files>Tests/Integration/FFU.Drivers.Integration.Tests.ps1</files>
  <action>
Run the tests and verify they pass. If any tests fail due to module structure differences, adjust the tests to match the actual module implementation.

Common adjustments needed:
1. Mock placement (may need InModuleScope)
2. Parameter name corrections
3. Function behavior matching

Run:
```powershell
Invoke-Pester -Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Drivers.Integration.Tests.ps1" -Output Detailed
```

If tests fail, examine the failure messages and update the test file to match actual module behavior while still testing the integration patterns.
  </action>
  <verify>
```powershell
$result = Invoke-Pester -Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Drivers.Integration.Tests.ps1" -PassThru
$result.FailedCount -eq 0
```
  </verify>
  <done>All driver integration tests pass, verifying parameter validation, mocked operations, and patterns</done>
</task>

</tasks>

<verification>
1. Test file exists and parses correctly:
   ```powershell
   Test-Path "C:\claude\FFUBuilder\Tests\Integration\FFU.Drivers.Integration.Tests.ps1"
   [System.Management.Automation.Language.Parser]::ParseFile("C:\claude\FFUBuilder\Tests\Integration\FFU.Drivers.Integration.Tests.ps1", [ref]$null, [ref]$null)
   ```

2. Tests run and pass:
   ```powershell
   Invoke-Pester -Path "Tests\Integration\FFU.Drivers.Integration.Tests.ps1" -Output Detailed
   ```

3. Count tests (should be 12+):
   ```powershell
   $result = Invoke-Pester -Path "Tests\Integration\FFU.Drivers.Integration.Tests.ps1" -PassThru
   $result.TotalCount
   ```
</verification>

<success_criteria>
- [ ] Tests/Integration/FFU.Drivers.Integration.Tests.ps1 created
- [ ] DISM stub functions created when cmdlets not available
- [ ] Copy-Drivers workflow tested with mocked file operations
- [ ] OEM driver functions tested without network calls
- [ ] 12+ tests covering driver filtering, extraction patterns, and injection
- [ ] All tests pass without requiring actual driver files or mounted images
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-tests-core/05-02-SUMMARY.md`
</output>
