---
phase: 05-integration-tests-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Tests/Integration/FFU.VM.Integration.Tests.ps1
autonomous: true

must_haves:
  truths:
    - "Integration tests verify VM creation workflow logic"
    - "Tests run on any machine (skip when Hyper-V unavailable)"
    - "Mock-based tests verify cmdlet parameter passing"
    - "Real infrastructure tests tagged for conditional execution"
  artifacts:
    - path: "Tests/Integration/FFU.VM.Integration.Tests.ps1"
      provides: "Integration tests for FFU.VM module"
      min_tests: 15
  key_links:
    - from: "Tests/Integration/FFU.VM.Integration.Tests.ps1"
      to: "FFU.VM.psm1"
      via: "Import-Module and function calls"
      pattern: "Import-Module.*FFU\\.VM"
---

<objective>
Create integration tests for Hyper-V VM creation and removal operations (TEST-01)

Purpose: Verify VM lifecycle operations work correctly with proper parameter passing, error handling, and cleanup. Tests should run on any machine via mocking, with optional real infrastructure tests for systems with Hyper-V enabled.

Output: Tests/Integration/FFU.VM.Integration.Tests.ps1 with 15+ tests covering New-FFUVM, Remove-FFUVM, Get-FFUEnvironment, Set-CaptureFFU, and related functions
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/05-integration-tests-core/05-RESEARCH.md

Key references:
- FFUDevelopment/Modules/FFU.VM/FFU.VM.psm1 (VM management functions)
- FFUDevelopment/Modules/FFU.VM/FFU.VM.psd1 (exports 13 functions)
- Tests/Unit/FFU.VM.Tests.ps1 (existing unit test patterns)
- Tests/Integration/Test-UIIntegration.ps1 (existing integration patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FFU.VM integration test file with infrastructure detection</name>
  <files>Tests/Integration/FFU.VM.Integration.Tests.ps1</files>
  <action>
Create new test file `Tests/Integration/FFU.VM.Integration.Tests.ps1`:

```powershell
#Requires -Version 5.1
#Requires -Modules @{ ModuleName = 'Pester'; ModuleVersion = '5.0.0' }

<#
.SYNOPSIS
    Pester integration tests for FFU.VM module

.DESCRIPTION
    Integration tests covering VM creation, removal, and capture setup.
    Tests use mocking for logic verification on any machine.
    Optional real infrastructure tests run only when Hyper-V is available.

.NOTES
    Run all: Invoke-Pester -Path .\Tests\Integration\FFU.VM.Integration.Tests.ps1 -Output Detailed
    Skip real infra: Invoke-Pester -Path .\Tests\Integration\FFU.VM.Integration.Tests.ps1 -ExcludeTag 'RealInfra'
    Coverage: TEST-01 - Integration tests for VM creation
#>

BeforeAll {
    # Get paths relative to test file location
    $TestRoot = Split-Path $PSScriptRoot -Parent
    $ProjectRoot = Split-Path $TestRoot -Parent
    $ModulesPath = Join-Path $ProjectRoot 'FFUDevelopment\Modules'
    $ModulePath = Join-Path $ModulesPath 'FFU.VM'

    # Add Modules folder to PSModulePath for RequiredModules resolution
    if ($env:PSModulePath -notlike "*$ModulesPath*") {
        $env:PSModulePath = "$ModulesPath;$env:PSModulePath"
    }

    # Infrastructure detection
    $script:HyperVAvailable = $false
    try {
        $service = Get-Service -Name vmms -ErrorAction Stop
        $script:HyperVAvailable = ($service.Status -eq 'Running')
    }
    catch {
        $script:HyperVAvailable = $false
    }

    # Create stub functions for Hyper-V cmdlets if module not available
    if (-not (Get-Module -Name Hyper-V -ListAvailable)) {
        function global:New-VM { param($Name, $Path, $MemoryStartupBytes, $VHDPath, $Generation) }
        function global:Set-VMProcessor { param($VMName, $Count) }
        function global:Add-VMDvdDrive { param($VMName, $Path) }
        function global:Get-VMHardDiskDrive { param($VMName) }
        function global:Set-VMFirmware { param($VMName, $FirstBootDevice) }
        function global:Set-VM { param($Name, $AutomaticCheckpointsEnabled, $StaticMemory) }
        function global:New-HgsGuardian { param($Name, $GenerateCertificates) }
        function global:Get-HgsGuardian { param($Name) }
        function global:New-HgsKeyProtector { param($Owner, $AllowUntrustedRoot) }
        function global:Set-VMKeyProtector { param($VMName, $KeyProtector) }
        function global:Enable-VMTPM { param($VMName) }
        function global:Start-VM { param($Name) }
        function global:Stop-VM { param($Name, $Force, $TurnOff) }
        function global:Remove-VM { param($Name, $Force) }
        function global:Get-VM { param($Name) }
        function global:Dismount-VHD { param($Path) }
        function global:Get-VMSwitch { param($Name, $SwitchType) }
    }

    # Remove and re-import module
    Get-Module -Name 'FFU.VM', 'FFU.Core', 'FFU.Hypervisor' | Remove-Module -Force -ErrorAction SilentlyContinue

    # Import FFU.VM (will auto-load dependencies)
    if (-not (Test-Path "$ModulePath\FFU.VM.psd1")) {
        throw "FFU.VM module not found at: $ModulePath"
    }
    Import-Module "$ModulePath\FFU.VM.psd1" -Force -ErrorAction Stop
}

AfterAll {
    Get-Module -Name 'FFU.VM', 'FFU.Core', 'FFU.Hypervisor' | Remove-Module -Force -ErrorAction SilentlyContinue
}

# =============================================================================
# Infrastructure Detection Tests
# =============================================================================

Describe 'FFU.VM Infrastructure Detection' -Tag 'Integration', 'FFU.VM', 'InfraDetection' {

    It 'Should detect Hyper-V availability' {
        # This just confirms detection works, not that Hyper-V is available
        $script:HyperVAvailable | Should -BeIn @($true, $false)
    }

    It 'Should report Hyper-V status for test planning' {
        if ($script:HyperVAvailable) {
            Write-Host "  [INFO] Hyper-V is AVAILABLE - real infrastructure tests will run" -ForegroundColor Green
        }
        else {
            Write-Host "  [INFO] Hyper-V is NOT available - using mocked tests only" -ForegroundColor Yellow
        }
        $true | Should -BeTrue  # Always passes, informational
    }
}
```

Continue in Task 2 with the mock-based integration tests.
  </action>
  <verify>
File exists and has basic structure:
```powershell
Test-Path "C:\claude\FFUBuilder\Tests\Integration\FFU.VM.Integration.Tests.ps1"
```
  </verify>
  <done>Test file created with infrastructure detection and stub function setup</done>
</task>

<task type="auto">
  <name>Task 2: Add mock-based VM creation integration tests</name>
  <files>Tests/Integration/FFU.VM.Integration.Tests.ps1</files>
  <action>
Append to the test file (after infrastructure detection section):

```powershell
# =============================================================================
# New-FFUVM Mock-Based Integration Tests
# =============================================================================

Describe 'New-FFUVM Integration' -Tag 'Integration', 'FFU.VM', 'VMCreation' {

    BeforeAll {
        # Mock WriteLog to avoid output during tests
        Mock WriteLog { } -ModuleName 'FFU.VM'
    }

    Context 'VM Creation Workflow (Mocked)' {

        BeforeEach {
            # Mock all Hyper-V cmdlets for workflow verification
            Mock New-VM {
                return [PSCustomObject]@{ Name = $Name; State = 'Off'; Generation = $Generation }
            } -ModuleName 'FFU.VM'
            Mock Set-VMProcessor { } -ModuleName 'FFU.VM'
            Mock Add-VMDvdDrive { } -ModuleName 'FFU.VM'
            Mock Get-VMHardDiskDrive {
                return [PSCustomObject]@{ Path = $VHDPath ?? 'C:\test.vhdx'; VMName = $VMName }
            } -ModuleName 'FFU.VM'
            Mock Set-VMFirmware { } -ModuleName 'FFU.VM'
            Mock Set-VM { } -ModuleName 'FFU.VM'
            Mock New-HgsGuardian {
                return [PSCustomObject]@{ Name = $Name }
            } -ModuleName 'FFU.VM'
            Mock Get-HgsGuardian {
                return [PSCustomObject]@{ Name = $Name ?? 'TestGuardian' }
            } -ModuleName 'FFU.VM'
            Mock New-HgsKeyProtector {
                return [PSCustomObject]@{ RawData = [byte[]]@(1,2,3,4) }
            } -ModuleName 'FFU.VM'
            Mock Set-VMKeyProtector { } -ModuleName 'FFU.VM'
            Mock Enable-VMTPM { } -ModuleName 'FFU.VM'
            Mock Start-VM { } -ModuleName 'FFU.VM'
            Mock vmconnect { } -ModuleName 'FFU.VM'
            Mock Test-Path { return $true } -ModuleName 'FFU.VM'
        }

        It 'Should call New-VM with Generation 2' {
            New-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Memory 8GB -VHDXPath 'C:\test.vhdx' -Processors 4 -AppsISO 'C:\apps.iso'

            Should -Invoke New-VM -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $Generation -eq 2
            }
        }

        It 'Should set VM processor count correctly' {
            New-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Memory 4GB -VHDXPath 'C:\test.vhdx' -Processors 8 -AppsISO 'C:\apps.iso'

            Should -Invoke Set-VMProcessor -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $Count -eq 8
            }
        }

        It 'Should configure VM memory' {
            New-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Memory 16GB -VHDXPath 'C:\test.vhdx' -Processors 4 -AppsISO 'C:\apps.iso'

            Should -Invoke New-VM -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $MemoryStartupBytes -eq 16GB
            }
        }

        It 'Should attach Apps ISO via DVD drive' {
            $testIsoPath = 'C:\FFU\Apps.iso'
            New-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Memory 8GB -VHDXPath 'C:\test.vhdx' -Processors 4 -AppsISO $testIsoPath

            Should -Invoke Add-VMDvdDrive -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $Path -eq $testIsoPath
            }
        }

        It 'Should configure TPM via HGS Guardian' {
            New-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Memory 8GB -VHDXPath 'C:\test.vhdx' -Processors 4 -AppsISO 'C:\apps.iso'

            # Verify TPM configuration was attempted
            Should -Invoke Enable-VMTPM -ModuleName 'FFU.VM' -Times 1
        }

        It 'Should start the VM after creation' {
            New-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Memory 8GB -VHDXPath 'C:\test.vhdx' -Processors 4 -AppsISO 'C:\apps.iso'

            Should -Invoke Start-VM -ModuleName 'FFU.VM' -Times 1
        }
    }

    Context 'Error Handling (Mocked)' {

        BeforeEach {
            Mock Test-Path { return $true } -ModuleName 'FFU.VM'
        }

        It 'Should throw when New-VM fails' {
            Mock New-VM { throw "Insufficient memory" } -ModuleName 'FFU.VM'

            { New-FFUVM -VMName '_FFU-Error-Test' -VMPath 'C:\VM' -Memory 8GB -VHDXPath 'C:\test.vhdx' -Processors 4 -AppsISO 'C:\apps.iso' } |
                Should -Throw
        }

        It 'Should throw when VHDX path does not exist' {
            Mock Test-Path { return $false } -ModuleName 'FFU.VM' -ParameterFilter { $Path -like '*.vhdx' }

            { New-FFUVM -VMName '_FFU-Test' -VMPath 'C:\VM' -Memory 8GB -VHDXPath 'C:\nonexistent.vhdx' -Processors 4 -AppsISO 'C:\apps.iso' } |
                Should -Throw
        }
    }
}
```
  </action>
  <verify>
Tests can be parsed:
```powershell
$ast = [System.Management.Automation.Language.Parser]::ParseFile("C:\claude\FFUBuilder\Tests\Integration\FFU.VM.Integration.Tests.ps1", [ref]$null, [ref]$null)
$ast.EndBlock.Statements.Count -gt 0
```
  </verify>
  <done>Mock-based VM creation tests added covering workflow, parameter passing, and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Add Remove-FFUVM and Set-CaptureFFU integration tests</name>
  <files>Tests/Integration/FFU.VM.Integration.Tests.ps1</files>
  <action>
Append to the test file:

```powershell
# =============================================================================
# Remove-FFUVM Mock-Based Integration Tests
# =============================================================================

Describe 'Remove-FFUVM Integration' -Tag 'Integration', 'FFU.VM', 'VMCleanup' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.VM'
    }

    Context 'VM Removal Workflow (Mocked)' {

        BeforeEach {
            Mock Get-VM {
                return [PSCustomObject]@{ Name = $Name; State = 'Running' }
            } -ModuleName 'FFU.VM'
            Mock Stop-VM { } -ModuleName 'FFU.VM'
            Mock Remove-VM { } -ModuleName 'FFU.VM'
            Mock Dismount-VHD { } -ModuleName 'FFU.VM'
            Mock Remove-Item { } -ModuleName 'FFU.VM'
            Mock Get-SmbShare { return $null } -ModuleName 'FFU.VM'
            Mock Test-Path { return $true } -ModuleName 'FFU.VM'
        }

        It 'Should stop VM before removal when running' {
            Remove-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Username 'ffu_user' -ShareName 'FFUCaptureShare'

            Should -Invoke Stop-VM -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $Name -eq '_FFU-Test-VM'
            }
        }

        It 'Should call Remove-VM after stopping' {
            Remove-FFUVM -VMName '_FFU-Test-VM' -VMPath 'C:\VM' -Username 'ffu_user' -ShareName 'FFUCaptureShare'

            Should -Invoke Remove-VM -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $Name -eq '_FFU-Test-VM'
            }
        }

        It 'Should handle VM not found gracefully' {
            Mock Get-VM { return $null } -ModuleName 'FFU.VM'

            # Should not throw when VM doesn't exist
            { Remove-FFUVM -VMName '_FFU-NonExistent' -VMPath 'C:\VM' -Username 'ffu_user' -ShareName 'FFUCaptureShare' } |
                Should -Not -Throw
        }
    }

    Context 'Cleanup Operations (Mocked)' {

        BeforeEach {
            Mock Get-VM { return $null } -ModuleName 'FFU.VM'
            Mock Remove-SmbShare { } -ModuleName 'FFU.VM'
            Mock Remove-Item { } -ModuleName 'FFU.VM'
            Mock Test-Path { return $true } -ModuleName 'FFU.VM'

            # Mock local user functions
            InModuleScope 'FFU.VM' {
                Mock Get-LocalUserAccount { return $null }
                Mock Remove-LocalUserAccount { return $true }
            }
        }

        It 'Should attempt user account cleanup' {
            Remove-FFUVM -VMName '_FFU-Test' -VMPath 'C:\VM' -Username 'ffu_user' -ShareName 'FFUCaptureShare'

            InModuleScope 'FFU.VM' {
                Should -Invoke Get-LocalUserAccount -Times 1
            }
        }
    }
}

# =============================================================================
# Set-CaptureFFU Mock-Based Integration Tests
# =============================================================================

Describe 'Set-CaptureFFU Integration' -Tag 'Integration', 'FFU.VM', 'CaptureSetup' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.VM'
    }

    Context 'Capture Setup Workflow (Mocked)' {

        BeforeEach {
            # Mock SMB share operations
            Mock Get-SmbShare { return $null } -ModuleName 'FFU.VM'
            Mock New-SmbShare { } -ModuleName 'FFU.VM'
            Mock Grant-SmbShareAccess { } -ModuleName 'FFU.VM'
            Mock New-Item { return [PSCustomObject]@{ FullName = $Path } } -ModuleName 'FFU.VM'
            Mock Test-Path { return $true } -ModuleName 'FFU.VM'

            # Mock local user functions within module scope
            InModuleScope 'FFU.VM' {
                Mock Get-LocalUserAccount { return $null }
                Mock New-LocalUserAccount { return $true }
                Mock Set-LocalUserAccountExpiry { return (Get-Date).AddHours(12) }
            }
        }

        It 'Should create local user for capture' {
            $password = ConvertTo-SecureString 'TestP@ss123!' -AsPlainText -Force

            Set-CaptureFFU -Username 'ffu_user' -ShareName 'FFUCaptureShare' -FFUCaptureLocation 'C:\FFU' -Password $password

            InModuleScope 'FFU.VM' {
                Should -Invoke New-LocalUserAccount -Times 1 -ParameterFilter {
                    $Username -eq 'ffu_user'
                }
            }
        }

        It 'Should create SMB share for FFU capture location' {
            $password = ConvertTo-SecureString 'TestP@ss123!' -AsPlainText -Force

            Set-CaptureFFU -Username 'ffu_user' -ShareName 'FFUCaptureShare' -FFUCaptureLocation 'C:\FFU' -Password $password

            Should -Invoke New-SmbShare -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $Name -eq 'FFUCaptureShare' -and $Path -eq 'C:\FFU'
            }
        }

        It 'Should grant share access to capture user' {
            $password = ConvertTo-SecureString 'TestP@ss123!' -AsPlainText -Force

            Set-CaptureFFU -Username 'ffu_user' -ShareName 'FFUCaptureShare' -FFUCaptureLocation 'C:\FFU' -Password $password

            Should -Invoke Grant-SmbShareAccess -ModuleName 'FFU.VM' -Times 1 -ParameterFilter {
                $AccountName -eq 'ffu_user'
            }
        }

        It 'Should set user account expiry' {
            $password = ConvertTo-SecureString 'TestP@ss123!' -AsPlainText -Force

            Set-CaptureFFU -Username 'ffu_user' -ShareName 'FFUCaptureShare' -FFUCaptureLocation 'C:\FFU' -Password $password

            InModuleScope 'FFU.VM' {
                Should -Invoke Set-LocalUserAccountExpiry -Times 1
            }
        }
    }

    Context 'Share Already Exists (Mocked)' {

        It 'Should skip share creation when share exists' {
            Mock Get-SmbShare { return [PSCustomObject]@{ Name = 'FFUCaptureShare' } } -ModuleName 'FFU.VM'
            Mock New-SmbShare { } -ModuleName 'FFU.VM'
            Mock Grant-SmbShareAccess { } -ModuleName 'FFU.VM'
            Mock Test-Path { return $true } -ModuleName 'FFU.VM'
            InModuleScope 'FFU.VM' {
                Mock Get-LocalUserAccount { return [PSCustomObject]@{ Name = 'ffu_user' } }
                Mock Set-LocalUserAccountExpiry { return (Get-Date).AddHours(12) }
            }

            $password = ConvertTo-SecureString 'TestP@ss123!' -AsPlainText -Force

            Set-CaptureFFU -Username 'ffu_user' -ShareName 'FFUCaptureShare' -FFUCaptureLocation 'C:\FFU' -Password $password

            Should -Invoke New-SmbShare -ModuleName 'FFU.VM' -Times 0
        }
    }
}

# =============================================================================
# Get-FFUEnvironment Mock-Based Integration Tests
# =============================================================================

Describe 'Get-FFUEnvironment Integration' -Tag 'Integration', 'FFU.VM', 'Environment' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.VM'
    }

    Context 'Environment Detection (Mocked)' {

        BeforeEach {
            Mock Get-VM {
                return @(
                    [PSCustomObject]@{ Name = '_FFU-Build-VM'; State = 'Running' },
                    [PSCustomObject]@{ Name = '_FFU-Test-VM'; State = 'Off' }
                )
            } -ModuleName 'FFU.VM'
            Mock Get-ChildItem { return @() } -ModuleName 'FFU.VM'
            Mock Test-Path { return $true } -ModuleName 'FFU.VM'
        }

        It 'Should find FFU VMs by name pattern' {
            $env = Get-FFUEnvironment -FFUDevelopmentPath 'C:\FFUDevelopment'

            # Verify Get-VM was called (may filter by pattern)
            Should -Invoke Get-VM -ModuleName 'FFU.VM'
        }

        It 'Should return environment information object' {
            $env = Get-FFUEnvironment -FFUDevelopmentPath 'C:\FFUDevelopment'

            $env | Should -Not -BeNullOrEmpty
        }
    }
}

# =============================================================================
# Real Infrastructure Tests (Conditional)
# =============================================================================

Describe 'FFU.VM Real Infrastructure Tests' -Tag 'Integration', 'FFU.VM', 'RealInfra' {

    BeforeAll {
        Mock WriteLog { } -ModuleName 'FFU.VM'
    }

    It 'Should query actual VMs when Hyper-V available' -Skip:(-not $script:HyperVAvailable) {
        # Real test - only runs when Hyper-V is available
        $vms = Get-VM -ErrorAction SilentlyContinue

        # Just verify we can query without error
        { Get-VM -ErrorAction Stop } | Should -Not -Throw
    }

    It 'Should detect FFU VMs in environment' -Skip:(-not $script:HyperVAvailable) {
        $env = Get-FFUEnvironment -FFUDevelopmentPath $env:TEMP

        # Environment function should work even with no FFU VMs
        $env | Should -Not -BeNullOrEmpty
    }
}
```
  </action>
  <verify>
Run the tests:
```powershell
Invoke-Pester -Path "C:\claude\FFUBuilder\Tests\Integration\FFU.VM.Integration.Tests.ps1" -Output Detailed -ExcludeTag 'RealInfra'
```
  </verify>
  <done>Remove-FFUVM, Set-CaptureFFU, and Get-FFUEnvironment integration tests added with mocking</done>
</task>

</tasks>

<verification>
1. Test file exists and parses correctly:
   ```powershell
   Test-Path "C:\claude\FFUBuilder\Tests\Integration\FFU.VM.Integration.Tests.ps1"
   [System.Management.Automation.Language.Parser]::ParseFile("C:\claude\FFUBuilder\Tests\Integration\FFU.VM.Integration.Tests.ps1", [ref]$null, [ref]$null)
   ```

2. Tests run without infrastructure:
   ```powershell
   Invoke-Pester -Path "Tests\Integration\FFU.VM.Integration.Tests.ps1" -ExcludeTag 'RealInfra' -Output Detailed
   ```

3. Count tests (should be 15+):
   ```powershell
   $result = Invoke-Pester -Path "Tests\Integration\FFU.VM.Integration.Tests.ps1" -PassThru -ExcludeTag 'RealInfra'
   $result.TotalCount
   ```
</verification>

<success_criteria>
- [ ] Tests/Integration/FFU.VM.Integration.Tests.ps1 created
- [ ] Infrastructure detection for Hyper-V works correctly
- [ ] Stub functions created when Hyper-V module not available
- [ ] 15+ tests covering VM creation, removal, capture setup, and environment
- [ ] Tests pass on machines without Hyper-V (via mocking)
- [ ] Real infrastructure tests tagged and skipped when unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-tests-core/05-01-SUMMARY.md`
</output>
