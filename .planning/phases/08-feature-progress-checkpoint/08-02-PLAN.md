---
phase: 08-feature-progress-checkpoint
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - FFUDevelopment/BuildFFUVM.ps1
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Checkpoint saved after each major build phase completes"
    - "Checkpoint includes current configuration, artifacts status, and paths"
    - "No sensitive data (passwords) included in checkpoint"
    - "Checkpoint save happens at existing cancellation checkpoint locations"
  artifacts:
    - path: "FFUDevelopment/BuildFFUVM.ps1"
      provides: "Checkpoint persistence integration"
      contains: "Save-FFUBuildCheckpoint"
  key_links:
    - from: "BuildFFUVM.ps1"
      to: "FFU.Checkpoint"
      via: "Import-Module and Save-FFUBuildCheckpoint calls"
      pattern: "Save-FFUBuildCheckpoint.*-CompletedPhase"
---

<objective>
Integrate checkpoint persistence into BuildFFUVM.ps1 at existing cancellation checkpoint locations.

Purpose: Save build state at each major phase boundary so interrupted builds can resume from the last checkpoint.
Output: BuildFFUVM.ps1 calls Save-FFUBuildCheckpoint at 8 strategic locations matching existing cancellation checkpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-feature-progress-checkpoint/08-RESEARCH.md
@.planning/phases/08-feature-progress-checkpoint/08-01-SUMMARY.md

# Key files
@FFUDevelopment/BuildFFUVM.ps1 (checkpoint locations: lines 1719, 2339, 3539, 3823, 4291, 4367, 4467, 4562, 4588)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FFU.Checkpoint module import</name>
  <files>
    FFUDevelopment/BuildFFUVM.ps1
  </files>
  <action>
Add FFU.Checkpoint to the module imports in BuildFFUVM.ps1:

1. Find the existing module import section (after param block, around lines 552-569)

2. Add FFU.Checkpoint import:
```powershell
Import-Module "FFU.Checkpoint" -Force -ErrorAction Stop
```

3. Add script-scoped variable to enable/disable checkpoints:
```powershell
# Checkpoint control - can be disabled via parameter if needed
$script:CheckpointEnabled = $true
```

4. Verify the import order - FFU.Checkpoint has no dependencies so it can go early in the list

**Important:** The module should be imported AFTER the PSModulePath is set up (line ~555) but can be before other modules that have dependencies.
  </action>
  <verify>
```powershell
# Check import added
Select-String -Path "C:\claude\FFUBuilder\FFUDevelopment\BuildFFUVM.ps1" -Pattern 'Import-Module.*FFU\.Checkpoint'
```
  </verify>
  <done>
FFU.Checkpoint module imported in BuildFFUVM.ps1 module import section.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add checkpoint saves at existing checkpoint locations</name>
  <files>
    FFUDevelopment/BuildFFUVM.ps1
  </files>
  <action>
Add Save-FFUBuildCheckpoint calls after each existing cancellation checkpoint. Each checkpoint saves appropriate state:

**CHECKPOINT 1 (line ~1719) - After Pre-flight Validation:**
```powershell
# === CHECKPOINT PERSISTENCE 1: After Pre-flight Validation ===
if ($script:CheckpointEnabled) {
    Save-FFUBuildCheckpoint -CompletedPhase PreflightValidation `
        -Configuration @{
            FFUDevelopmentPath = $FFUDevelopmentPath
            WindowsRelease = $WindowsRelease
            WindowsVersion = $WindowsVersion
            WindowsSKU = $WindowsSKU
            InstallApps = $InstallApps
            HypervisorType = $HypervisorType
            VMName = $VMName
            OEM = $OEM
            Model = $Model
        } `
        -Artifacts @{
            preflightValidated = $true
        } `
        -Paths @{
            FFUDevelopmentPath = $FFUDevelopmentPath
        } `
        -FFUDevelopmentPath $FFUDevelopmentPath
}
```

**CHECKPOINT 2 (line ~2339) - After Driver Download:**
Add after cancellation checkpoint 2, include driversDownloaded, DriversFolder path

**CHECKPOINT 3 (line ~3539) - Before VHDX Creation:**
Add before VHDX creation, include all download artifacts status

**CHECKPOINT 4 (line ~3823) - After VHDX Creation:**
Add after VHDX created, include VHDXPath, vhdxCreated = $true

**CHECKPOINT 5 (line ~4291) - Before VM Start:**
Add before VM start, include VMName, vmCreated = $true

**CHECKPOINT 6a (line ~4367) - Before FFU Capture (non-InstallApps path):**
Add for non-InstallApps flow, vmReady = $true

**CHECKPOINT 6b (line ~4467) - After VM Shutdown (InstallApps path):**
Add for InstallApps flow, appsInstalled = $true, vmShutdown = $true

**CHECKPOINT 7 (line ~4562) - Before Deployment Media:**
Add before deployment media creation, ffuCaptured = $true, FFUPath

**CHECKPOINT 8 (line ~4588) - Before USB Creation:**
Add before USB creation, deploymentMediaCreated = $true

**Key rules:**
- NEVER include FFUCaptureUsername or FFUCapturePassword in checkpoint
- Include paths that would be needed to resume (VHDXPath, VMPath, DriversFolder)
- Include boolean artifact flags for what's complete
- Use $script:CheckpointEnabled guard around each save
  </action>
  <verify>
```powershell
# Count checkpoint persistence calls
(Select-String -Path "C:\claude\FFUBuilder\FFUDevelopment\BuildFFUVM.ps1" -Pattern 'CHECKPOINT PERSISTENCE').Count -eq 8

# Verify no passwords in checkpoint calls
-not (Select-String -Path "C:\claude\FFUBuilder\FFUDevelopment\BuildFFUVM.ps1" -Pattern 'Save-FFUBuildCheckpoint.*Password')
```
  </verify>
  <done>
8 checkpoint persistence calls added to BuildFFUVM.ps1, no sensitive data included.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add checkpoint cleanup on successful completion</name>
  <files>
    FFUDevelopment/BuildFFUVM.ps1
  </files>
  <action>
Add checkpoint cleanup when build completes successfully:

1. Find the build completion section (near end of PROCESS block)

2. Add checkpoint removal on success:
```powershell
# === BUILD COMPLETE - Remove checkpoint ===
if ($script:CheckpointEnabled) {
    Remove-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath
    WriteLog "Build completed successfully - checkpoint removed"
}
```

3. This ensures:
   - Successful builds don't leave stale checkpoints
   - Only interrupted/failed builds have checkpoints for resume
   - Clean state after normal completion

**Location:** After the final success message but before any cleanup/return statements
  </action>
  <verify>
```powershell
# Verify checkpoint removal on success
Select-String -Path "C:\claude\FFUBuilder\FFUDevelopment\BuildFFUVM.ps1" -Pattern 'Remove-FFUBuildCheckpoint'
```
  </verify>
  <done>
Checkpoint removed on successful build completion. Stale checkpoints prevented.
  </done>
</task>

</tasks>

<verification>
1. Module import present: `Select-String -Pattern 'FFU\.Checkpoint'` shows import
2. Eight checkpoint persistence calls: Each cancellation checkpoint has matching persistence
3. No passwords in checkpoints: No FFUCapturePassword references in Save-FFUBuildCheckpoint calls
4. Cleanup on success: Remove-FFUBuildCheckpoint called at build completion
5. Script still parses: `pwsh -File BuildFFUVM.ps1 -?` shows help (syntax valid)
</verification>

<success_criteria>
- FFU.Checkpoint imported in BuildFFUVM.ps1
- 8 Save-FFUBuildCheckpoint calls at strategic locations
- Each checkpoint saves appropriate configuration, artifacts, and paths
- No sensitive data (passwords, credentials) in any checkpoint
- Checkpoint removed on successful completion
- Script parses without syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-feature-progress-checkpoint/08-02-SUMMARY.md`
</output>
