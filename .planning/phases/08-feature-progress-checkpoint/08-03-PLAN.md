---
phase: 08-feature-progress-checkpoint
plan: 03
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - FFUDevelopment/BuildFFUVM.ps1
  - FFUDevelopment/Modules/FFU.Checkpoint/FFU.Checkpoint.psm1
  - Tests/Unit/FFU.Checkpoint.Resume.Tests.ps1
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Script detects existing checkpoint on startup"
    - "User can choose to resume or start fresh"
    - "Resume skips completed phases"
    - "Artifacts are validated before resume"
    - "Invalid checkpoints are rejected gracefully"
  artifacts:
    - path: "FFUDevelopment/BuildFFUVM.ps1"
      provides: "Resume detection and phase skip logic"
      contains: "Test-PhaseAlreadyComplete"
    - path: "FFUDevelopment/Modules/FFU.Checkpoint/FFU.Checkpoint.psm1"
      provides: "Resume helper functions"
      exports: ["Test-PhaseAlreadyComplete", "Test-CheckpointArtifacts"]
    - path: "Tests/Unit/FFU.Checkpoint.Resume.Tests.ps1"
      provides: "Resume functionality tests"
      min_lines: 100
  key_links:
    - from: "BuildFFUVM.ps1 BEGIN block"
      to: "Get-FFUBuildCheckpoint"
      via: "Checkpoint detection"
      pattern: "Get-FFUBuildCheckpoint.*FFUDevelopmentPath"
    - from: "BuildFFUVM.ps1 phases"
      to: "Test-PhaseAlreadyComplete"
      via: "Phase skip decisions"
      pattern: "Test-PhaseAlreadyComplete.*-PhaseName"
---

<objective>
Add resume detection logic, phase skip functionality, and comprehensive tests for checkpoint/resume.

Purpose: Enable builds to detect and resume from checkpoints, skipping completed phases while validating artifact existence.
Output: Working resume functionality with user prompt, phase skip logic, and test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-feature-progress-checkpoint/08-RESEARCH.md
@.planning/phases/08-feature-progress-checkpoint/08-01-SUMMARY.md
@.planning/phases/08-feature-progress-checkpoint/08-02-SUMMARY.md

# Key files
@FFUDevelopment/BuildFFUVM.ps1
@FFUDevelopment/Modules/FFU.Checkpoint/FFU.Checkpoint.psm1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resume helper functions to FFU.Checkpoint</name>
  <files>
    FFUDevelopment/Modules/FFU.Checkpoint/FFU.Checkpoint.psm1
    FFUDevelopment/Modules/FFU.Checkpoint/FFU.Checkpoint.psd1
  </files>
  <action>
Add two new functions to FFU.Checkpoint module:

1. **Test-CheckpointArtifacts** function:
```powershell
function Test-CheckpointArtifacts {
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [hashtable]$Checkpoint
    )

    # Check each artifact marked as created
    $artifacts = $Checkpoint.artifacts
    $paths = $Checkpoint.paths

    # Validate VHDX if marked created
    if ($artifacts.vhdxCreated -and $paths.VHDXPath) {
        if (-not (Test-Path $paths.VHDXPath)) {
            Write-Verbose "Artifact missing: VHDXPath ($($paths.VHDXPath))"
            return $false
        }
    }

    # Validate VM exists if marked created (Hyper-V)
    if ($artifacts.vmCreated -and $Checkpoint.configuration.HypervisorType -eq 'HyperV') {
        $vmName = $Checkpoint.configuration.VMName
        try {
            $vm = Get-VM -Name $vmName -ErrorAction SilentlyContinue
            if (-not $vm) {
                Write-Verbose "Artifact missing: VM '$vmName'"
                return $false
            }
        }
        catch {
            Write-Verbose "Cannot verify VM: $_"
            # Don't fail if Hyper-V not available - validation will catch at runtime
        }
    }

    # Validate drivers folder if marked downloaded
    if ($artifacts.driversDownloaded -and $paths.DriversFolder) {
        if (-not (Test-Path $paths.DriversFolder)) {
            Write-Verbose "Artifact missing: DriversFolder ($($paths.DriversFolder))"
            return $false
        }
    }

    return $true
}
```

2. **Test-PhaseAlreadyComplete** function:
```powershell
function Test-PhaseAlreadyComplete {
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [string]$PhaseName,

        [Parameter()]
        [hashtable]$Checkpoint
    )

    if ($null -eq $Checkpoint) {
        return $false
    }

    # Phase ordering map
    $phaseOrder = @{
        'PreflightValidation' = 1
        'DriverDownload' = 2
        'UpdatesDownload' = 3
        'AppsPreparation' = 4
        'VHDXCreation' = 5
        'WindowsUpdates' = 6
        'VMSetup' = 7
        'VMStart' = 8
        'AppInstallation' = 9
        'VMShutdown' = 10
        'FFUCapture' = 11
        'DeploymentMedia' = 12
        'USBCreation' = 13
    }

    $currentPhaseOrder = $phaseOrder[$PhaseName]
    $lastCompletedPhase = $Checkpoint.lastCompletedPhase
    $checkpointPhaseOrder = $phaseOrder[$lastCompletedPhase]

    if ($null -eq $currentPhaseOrder) {
        Write-Verbose "Unknown phase: $PhaseName"
        return $false
    }

    if ($null -eq $checkpointPhaseOrder) {
        Write-Verbose "Unknown checkpoint phase: $lastCompletedPhase"
        return $false
    }

    if ($currentPhaseOrder -le $checkpointPhaseOrder) {
        if (Get-Command WriteLog -ErrorAction SilentlyContinue) {
            WriteLog "Skipping phase '$PhaseName' - already completed in checkpoint"
        }
        return $true
    }

    return $false
}
```

3. Update module manifest (psd1) to export new functions:
   - Add Test-CheckpointArtifacts to FunctionsToExport
   - Add Test-PhaseAlreadyComplete to FunctionsToExport
  </action>
  <verify>
```powershell
Import-Module "C:\claude\FFUBuilder\FFUDevelopment\Modules\FFU.Checkpoint" -Force

# Verify new exports
(Get-Command -Module FFU.Checkpoint).Name -contains 'Test-CheckpointArtifacts'
(Get-Command -Module FFU.Checkpoint).Name -contains 'Test-PhaseAlreadyComplete'
```
  </verify>
  <done>
Test-CheckpointArtifacts and Test-PhaseAlreadyComplete functions added and exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add resume detection to BuildFFUVM.ps1 BEGIN block</name>
  <files>
    FFUDevelopment/BuildFFUVM.ps1
  </files>
  <action>
Add checkpoint detection and resume logic to the BEGIN block of BuildFFUVM.ps1:

1. **Add script-scoped resume state variables** (after module imports):
```powershell
# Resume state
$script:ResumeCheckpoint = $null
$script:IsResuming = $false
```

2. **Add checkpoint detection** (in BEGIN block, after module imports but before main logic):
```powershell
# === CHECKPOINT RESUME DETECTION ===
$checkpointPath = Join-Path $FFUDevelopmentPath ".ffubuilder\checkpoint.json"

if (Test-Path $checkpointPath) {
    WriteLog "Found existing build checkpoint"

    try {
        $potentialCheckpoint = Get-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath

        if ($null -ne $potentialCheckpoint) {
            # Validate checkpoint
            if (-not (Test-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath -Checkpoint $potentialCheckpoint)) {
                WriteLog "WARNING: Checkpoint validation failed, will start fresh build"
                Remove-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath
            }
            elseif (-not (Test-CheckpointArtifacts -Checkpoint $potentialCheckpoint)) {
                WriteLog "WARNING: Checkpoint artifacts missing, will start fresh build"
                Remove-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath
            }
            else {
                $lastPhase = $potentialCheckpoint.lastCompletedPhase
                $timestamp = $potentialCheckpoint.timestamp

                WriteLog "Valid checkpoint from $timestamp at phase: $lastPhase"

                # Determine resume: UI mode vs CLI mode
                $shouldResume = $false

                if ($MessagingContext) {
                    # UI mode: Send message for UI to show resume dialog
                    # UI will set resume flag via different mechanism
                    # For now, default to resume in UI mode
                    WriteLog "UI mode: Resuming from checkpoint (phase: $lastPhase)"
                    $shouldResume = $true
                }
                else {
                    # CLI mode: Prompt user
                    Write-Host "`nFound interrupted build from $timestamp" -ForegroundColor Yellow
                    Write-Host "Last completed phase: $lastPhase" -ForegroundColor Yellow
                    $response = Read-Host "Resume from this checkpoint? (Y/N)"

                    if ($response -eq 'Y' -or $response -eq 'y') {
                        $shouldResume = $true
                    }
                    else {
                        WriteLog "User chose fresh build - removing checkpoint"
                        Remove-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath
                    }
                }

                if ($shouldResume) {
                    $script:ResumeCheckpoint = $potentialCheckpoint
                    $script:IsResuming = $true

                    # Restore paths from checkpoint
                    if ($potentialCheckpoint.paths.VHDXPath) {
                        $script:ResumedVHDXPath = $potentialCheckpoint.paths.VHDXPath
                    }
                    if ($potentialCheckpoint.paths.VMPath) {
                        $script:ResumedVMPath = $potentialCheckpoint.paths.VMPath
                    }

                    WriteLog "Resuming build from phase: $lastPhase"
                }
            }
        }
    }
    catch {
        WriteLog "WARNING: Failed to process checkpoint, starting fresh: $_"
        Remove-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath -ErrorAction SilentlyContinue
    }
}
```

3. **Add -NoResume parameter** to param block (optional, for forcing fresh build):
```powershell
[Parameter()]
[switch]$NoResume
```

4. **Handle NoResume flag**:
```powershell
if ($NoResume -and (Test-Path $checkpointPath)) {
    WriteLog "NoResume flag set - removing existing checkpoint"
    Remove-FFUBuildCheckpoint -FFUDevelopmentPath $FFUDevelopmentPath
}
```
  </action>
  <verify>
```powershell
# Verify resume detection code present
Select-String -Path "C:\claude\FFUBuilder\FFUDevelopment\BuildFFUVM.ps1" -Pattern 'CHECKPOINT RESUME DETECTION'
Select-String -Path "C:\claude\FFUBuilder\FFUDevelopment\BuildFFUVM.ps1" -Pattern '\$script:ResumeCheckpoint'
```
  </verify>
  <done>
Resume detection logic added to BEGIN block with CLI prompt and UI mode support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add phase skip checks throughout BuildFFUVM.ps1</name>
  <files>
    FFUDevelopment/BuildFFUVM.ps1
  </files>
  <action>
Add phase skip checks at the beginning of each major phase section:

1. **Driver Download phase** (around line 2339):
```powershell
# === PHASE: Driver Download ===
if ($script:IsResuming -and (Test-PhaseAlreadyComplete -PhaseName 'DriverDownload' -Checkpoint $script:ResumeCheckpoint)) {
    WriteLog "RESUME: Skipping Driver Download - already completed"
    # Restore drivers folder path from checkpoint
    $DriversFolder = $script:ResumeCheckpoint.paths.DriversFolder
}
else {
    # ... existing driver download code ...
}
```

2. **VHDX Creation phase** (around line 3539):
```powershell
if ($script:IsResuming -and (Test-PhaseAlreadyComplete -PhaseName 'VHDXCreation' -Checkpoint $script:ResumeCheckpoint)) {
    WriteLog "RESUME: Skipping VHDX Creation - already completed"
    $VHDXPath = $script:ResumedVHDXPath
    $VMPath = $script:ResumedVMPath
}
else {
    # ... existing VHDX creation code ...
}
```

3. **VM Setup phase** (around line 3823):
```powershell
if ($script:IsResuming -and (Test-PhaseAlreadyComplete -PhaseName 'VMSetup' -Checkpoint $script:ResumeCheckpoint)) {
    WriteLog "RESUME: Skipping VM Setup - already completed"
    # VM should already exist, just get reference
    $FFUBuildVM = Get-VM -Name $VMName -ErrorAction SilentlyContinue
}
else {
    # ... existing VM setup code ...
}
```

4. **VM Start phase** (around line 4291):
   Add similar skip check for VM start phase

5. **App Installation phase** (around line 4367):
   Add skip check for app installation

6. **FFU Capture phase** (around line 4467):
   Add skip check for FFU capture

7. **Deployment Media phase** (around line 4562):
   Add skip check for deployment media

8. **USB Creation phase** (around line 4588):
   Add skip check for USB creation

**Pattern for each phase:**
```powershell
if ($script:IsResuming -and (Test-PhaseAlreadyComplete -PhaseName '<PhaseName>' -Checkpoint $script:ResumeCheckpoint)) {
    WriteLog "RESUME: Skipping <PhaseName> - already completed"
    # Restore any needed state from checkpoint
}
else {
    # ... existing phase code ...
}
```
  </action>
  <verify>
```powershell
# Count phase skip checks
(Select-String -Path "C:\claude\FFUBuilder\FFUDevelopment\BuildFFUVM.ps1" -Pattern 'RESUME: Skipping').Count -ge 6
```
  </verify>
  <done>
Phase skip checks added to major build phases, allowing resumed builds to skip completed work.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create resume functionality tests</name>
  <files>
    Tests/Unit/FFU.Checkpoint.Resume.Tests.ps1
  </files>
  <action>
Create comprehensive Pester 5.x tests for resume functionality:

1. **Describe "Test-CheckpointArtifacts"**:
   - It "returns true when all artifacts exist"
   - It "returns false when VHDX missing"
   - It "returns false when drivers folder missing"
   - It "returns true when artifact not marked as created"
   - It "handles missing paths gracefully"

2. **Describe "Test-PhaseAlreadyComplete"**:
   - It "returns false when no checkpoint"
   - It "returns true when phase already completed"
   - It "returns false when phase not yet reached"
   - It "returns false for unknown phase name"
   - It "handles edge cases (first phase, last phase)"

3. **Describe "Resume Detection Integration"**:
   - It "detects valid checkpoint"
   - It "rejects invalid checkpoint version"
   - It "rejects checkpoint with missing artifacts"
   - It "cleans up invalid checkpoints"

4. **Describe "Phase Skip Logic"**:
   - It "skips PreflightValidation when checkpoint past it"
   - It "skips DriverDownload when checkpoint past it"
   - It "does not skip phases after checkpoint"
   - It "restores paths from checkpoint"

5. **Describe "End-to-End Resume Flow"** (mock-based):
   - It "saves checkpoint at phase boundary"
   - It "loads checkpoint on restart"
   - It "skips completed phases on resume"
   - It "continues from correct phase"

Use BeforeAll/AfterAll for setup/teardown. Create test checkpoints in $TestDrive.
  </action>
  <verify>
```powershell
Invoke-Pester -Path "C:\claude\FFUBuilder\Tests\Unit\FFU.Checkpoint.Resume.Tests.ps1" -Output Detailed -PassThru
```
  </verify>
  <done>
FFU.Checkpoint.Resume.Tests.ps1 exists with 25+ tests covering resume functionality, all tests pass.
  </done>
</task>

</tasks>

<verification>
1. New functions exported: Test-CheckpointArtifacts, Test-PhaseAlreadyComplete
2. Resume detection in BEGIN block with user prompt
3. Phase skip checks throughout BuildFFUVM.ps1 (6+ phases)
4. NoResume parameter available for forcing fresh builds
5. All tests pass in both test files
</verification>

<success_criteria>
- Test-CheckpointArtifacts validates artifact paths exist
- Test-PhaseAlreadyComplete determines if phase should be skipped
- Resume detection prompts user (CLI) or auto-resumes (UI)
- 6+ phases have skip checks when resuming
- NoResume parameter forces fresh build
- 25+ new tests pass
- Total checkpoint/resume test coverage: 45+ tests
</success_criteria>

<output>
After completion, create `.planning/phases/08-feature-progress-checkpoint/08-03-SUMMARY.md`
</output>
