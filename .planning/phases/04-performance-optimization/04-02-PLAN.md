---
phase: 04-performance-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - FFUDevelopment/Modules/FFU.Hypervisor/Public/Wait-VMStateChange.ps1
  - FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1
  - FFUDevelopment/Modules/FFU.Hypervisor/FFU.Hypervisor.psd1
  - Tests/Unit/FFU.Hypervisor.EventDriven.Tests.ps1
autonomous: true

must_haves:
  truths:
    - "Hyper-V VM state monitoring uses CIM event subscription"
    - "VMware state monitoring keeps existing polling (no CIM support)"
    - "Event-driven wait has configurable timeout"
    - "Event subscription is cleaned up even on error"
  artifacts:
    - path: "FFUDevelopment/Modules/FFU.Hypervisor/Public/Wait-VMStateChange.ps1"
      provides: "Event-driven VM state wait for Hyper-V"
      contains: "Register-CimIndicationEvent"
    - path: "Tests/Unit/FFU.Hypervisor.EventDriven.Tests.ps1"
      provides: "Pester tests for event-driven VM monitoring"
      min_tests: 6
  key_links:
    - from: "HyperVProvider.ps1"
      to: "Wait-VMStateChange.ps1"
      via: "WaitForState method using new function"
      pattern: "Wait-VMStateChange"
---

<objective>
Add event-driven VM state monitoring for Hyper-V using Register-CimIndicationEvent

Purpose: Replace polling loops with WMI event subscription for VM state changes on Hyper-V. VMware lacks CIM event support, so it keeps polling. This reduces CPU usage and provides faster response when VMs change state.

Output: Wait-VMStateChange function using CIM events, integrated into HyperVProvider
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/04-performance-optimization/04-RESEARCH.md

Key files:
- FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1
- FFUDevelopment/BuildFFUVM.ps1 (lines 4292-4310 startup polling, 4379-4411 shutdown polling)

Note: The VM polling loops in BuildFFUVM.ps1 use the hypervisor provider's GetVMState method. By adding a WaitForState method to HyperVProvider, we can offer event-driven waiting without changing BuildFFUVM.ps1 extensively.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Wait-VMStateChange function with CIM events</name>
  <files>FFUDevelopment/Modules/FFU.Hypervisor/Public/Wait-VMStateChange.ps1</files>
  <action>
Create new file `FFUDevelopment/Modules/FFU.Hypervisor/Public/Wait-VMStateChange.ps1`:

```powershell
#Requires -Version 5.1

<#
.SYNOPSIS
    Wait for Hyper-V VM to reach specified state using CIM event subscription.

.DESCRIPTION
    Uses Register-CimIndicationEvent to subscribe to Msvm_ComputerSystem state changes
    instead of polling. This is more efficient and provides faster response than
    Start-Sleep polling loops.

    For VMware VMs, use traditional polling as VMware lacks CIM event support.

.PARAMETER VMName
    Name of the Hyper-V virtual machine to monitor.

.PARAMETER TargetState
    Desired VM state to wait for: Running, Off, Paused, Saved.

.PARAMETER TimeoutSeconds
    Maximum time to wait for state change. Default is 3600 (1 hour).

.PARAMETER PollFallbackMs
    Milliseconds between event checks. The event subscription is async,
    so we need a small sleep to allow PowerShell to process events.
    Default is 500ms. This is NOT polling the VM - just allowing event processing.

.OUTPUTS
    [bool] True if target state reached, False if timeout exceeded.

.EXAMPLE
    Wait-VMStateChange -VMName "FFU_Build_VM" -TargetState Off -TimeoutSeconds 1800
    # Waits up to 30 minutes for VM to shut down

.NOTES
    PERF-02: Event-driven VM state monitoring for Hyper-V
    Replaces polling loops with WMI event subscription.
#>
function Wait-VMStateChange {
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [string]$VMName,

        [Parameter(Mandatory)]
        [ValidateSet('Running', 'Off', 'Paused', 'Saved')]
        [string]$TargetState,

        [int]$TimeoutSeconds = 3600,

        [int]$PollFallbackMs = 500
    )

    # Map state names to EnabledState values
    # See: https://learn.microsoft.com/en-us/windows/win32/hyperv_v2/msvm-computersystem
    $stateMap = @{
        'Running' = 2    # Enabled
        'Off'     = 3    # Disabled
        'Paused'  = 32768  # Paused
        'Saved'   = 32769  # Suspended
    }
    $targetStateValue = $stateMap[$TargetState]

    # Check current state first - may already be at target
    $currentVM = Get-VM -Name $VMName -ErrorAction SilentlyContinue
    if (-not $currentVM) {
        Write-Warning "VM '$VMName' not found"
        return $false
    }

    $currentState = switch ($currentVM.State) {
        'Running' { 2 }
        'Off' { 3 }
        'Paused' { 32768 }
        'Saved' { 32769 }
        default { 0 }
    }

    if ($currentState -eq $targetStateValue) {
        Write-Verbose "VM '$VMName' is already in state '$TargetState'"
        return $true
    }

    # Unique source identifier for this subscription
    $sourceId = "VMStateChange_$VMName_$([Guid]::NewGuid().ToString('N'))"

    # Use script-scope variable for event communication
    $script:VMStateReached = $false

    try {
        # WQL query for VM state modification
        # WITHIN 2 = check every 2 seconds (balance between responsiveness and CPU)
        $query = @"
SELECT * FROM __InstanceModificationEvent WITHIN 2
WHERE TargetInstance ISA 'Msvm_ComputerSystem'
AND TargetInstance.ElementName = '$VMName'
"@

        Write-Verbose "Registering CIM event subscription for VM '$VMName' target state '$TargetState'"
        Write-Verbose "WQL Query: $query"

        # Register for indication with action block
        $eventJob = Register-CimIndicationEvent `
            -Query $query `
            -Namespace "root\virtualization\v2" `
            -SourceIdentifier $sourceId `
            -Action {
                $vm = $Event.SourceEventArgs.NewEvent.TargetInstance
                $currentEnabled = $vm.EnabledState

                # Access target from outer scope - use event MessageData
                if ($currentEnabled -eq $Event.MessageData.TargetStateValue) {
                    $script:VMStateReached = $true
                }
            } -MessageData @{ TargetStateValue = $targetStateValue }

        # Wait with timeout, checking for event
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

        while (-not $script:VMStateReached -and $stopwatch.Elapsed.TotalSeconds -lt $TimeoutSeconds) {
            # Brief sleep to allow PowerShell to process events
            # This is NOT polling the VM - just allowing the event system to work
            Start-Sleep -Milliseconds $PollFallbackMs

            # Also check VM state directly in case event was missed
            # (defense in depth - events can occasionally be dropped)
            $checkVM = Get-VM -Name $VMName -ErrorAction SilentlyContinue
            if ($checkVM) {
                $checkState = switch ($checkVM.State) {
                    'Running' { 2 }
                    'Off' { 3 }
                    'Paused' { 32768 }
                    'Saved' { 32769 }
                    default { 0 }
                }
                if ($checkState -eq $targetStateValue) {
                    $script:VMStateReached = $true
                }
            }

            # Log progress every 30 seconds
            if ($stopwatch.Elapsed.TotalSeconds % 30 -lt 1) {
                Write-Verbose "Waiting for VM '$VMName' to reach state '$TargetState' (elapsed: $([int]$stopwatch.Elapsed.TotalSeconds)s)"
            }
        }

        $elapsed = $stopwatch.Elapsed.TotalSeconds
        if ($script:VMStateReached) {
            Write-Verbose "VM '$VMName' reached state '$TargetState' after $([int]$elapsed) seconds"
            return $true
        }
        else {
            Write-Warning "Timeout waiting for VM '$VMName' to reach state '$TargetState' after $TimeoutSeconds seconds"
            return $false
        }
    }
    finally {
        # Always clean up event subscription
        Unregister-Event -SourceIdentifier $sourceId -ErrorAction SilentlyContinue
        Remove-Job -Name $sourceId -Force -ErrorAction SilentlyContinue
        Remove-Variable -Name VMStateReached -Scope Script -ErrorAction SilentlyContinue
        Write-Verbose "Cleaned up CIM event subscription '$sourceId'"
    }
}

Export-ModuleMember -Function Wait-VMStateChange
```
  </action>
  <verify>
File exists and has correct content:
```powershell
Test-Path "FFUDevelopment\Modules\FFU.Hypervisor\Public\Wait-VMStateChange.ps1"
Select-String -Path "FFUDevelopment\Modules\FFU.Hypervisor\Public\Wait-VMStateChange.ps1" -Pattern "Register-CimIndicationEvent"
```
  </verify>
  <done>Wait-VMStateChange.ps1 created with CIM event subscription, timeout handling, and cleanup in finally block</done>
</task>

<task type="auto">
  <name>Task 2: Add WaitForState method to HyperVProvider</name>
  <files>FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1, FFUDevelopment/Modules/FFU.Hypervisor/FFU.Hypervisor.psd1</files>
  <action>
In HyperVProvider.ps1, add a WaitForState method to the HyperVProvider class that uses the new Wait-VMStateChange function:

1. Find the HyperVProvider class definition
2. Add a new method `WaitForState`:

```powershell
    [bool] WaitForState([object]$VM, [string]$TargetState, [int]$TimeoutSeconds) {
        <#
        .SYNOPSIS
            Wait for VM to reach specified state using event-driven monitoring.
        .DESCRIPTION
            Uses CIM event subscription instead of polling for efficient state monitoring.
        #>
        $vmName = if ($VM -is [Microsoft.HyperV.PowerShell.VirtualMachine]) {
            $VM.Name
        } else {
            $VM.VMName
        }

        # Delegate to event-driven function
        return Wait-VMStateChange -VMName $vmName -TargetState $TargetState -TimeoutSeconds $TimeoutSeconds
    }
```

Also add to IHypervisorProvider interface (Classes/IHypervisorProvider.ps1) if it exists:
```powershell
    [bool] WaitForState([object]$VM, [string]$TargetState, [int]$TimeoutSeconds)
```

**Update module manifest** (FFU.Hypervisor.psd1):
- Add `Wait-VMStateChange` to FunctionsToExport
- Increment ModuleVersion
- Add release note: "Add event-driven VM state monitoring for Hyper-V (PERF-02)"
  </action>
  <verify>
1. HyperVProvider has WaitForState method:
```powershell
Select-String -Path "FFUDevelopment\Modules\FFU.Hypervisor\Providers\HyperVProvider.ps1" -Pattern "WaitForState"
```

2. Function is exported:
```powershell
Import-Module "FFUDevelopment\Modules\FFU.Hypervisor" -Force
Get-Command Wait-VMStateChange -ErrorAction SilentlyContinue
```
  </verify>
  <done>HyperVProvider.WaitForState method delegates to Wait-VMStateChange, module exports the function</done>
</task>

<task type="auto">
  <name>Task 3: Add Pester tests for event-driven monitoring</name>
  <files>Tests/Unit/FFU.Hypervisor.EventDriven.Tests.ps1</files>
  <action>
Create `Tests/Unit/FFU.Hypervisor.EventDriven.Tests.ps1`:

```powershell
#Requires -Modules Pester

<#
.SYNOPSIS
    Pester tests for FFU.Hypervisor event-driven VM state monitoring (PERF-02)

.DESCRIPTION
    Tests Wait-VMStateChange function behavior including:
    - CIM event registration
    - State detection
    - Timeout handling
    - Cleanup on exit
#>

BeforeAll {
    $modulePath = Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.Hypervisor"
    Import-Module $modulePath -Force -ErrorAction Stop
}

Describe "Wait-VMStateChange" {

    Context "When VM is already in target state" {

        BeforeEach {
            Mock Get-VM {
                return [PSCustomObject]@{
                    Name = 'TestVM'
                    State = 'Off'
                }
            } -ModuleName FFU.Hypervisor
        }

        It "Should return true immediately without waiting" {
            $result = Wait-VMStateChange -VMName 'TestVM' -TargetState 'Off' -TimeoutSeconds 5

            $result | Should -Be $true
        }
    }

    Context "When VM does not exist" {

        BeforeEach {
            Mock Get-VM { return $null } -ModuleName FFU.Hypervisor
        }

        It "Should return false with warning" {
            $result = Wait-VMStateChange -VMName 'NonExistentVM' -TargetState 'Off' -TimeoutSeconds 5 -WarningAction SilentlyContinue

            $result | Should -Be $false
        }
    }

    Context "CIM Event Registration" {

        BeforeEach {
            # VM starts Running, needs to wait for Off
            Mock Get-VM {
                return [PSCustomObject]@{
                    Name = 'TestVM'
                    State = 'Running'
                }
            } -ModuleName FFU.Hypervisor

            Mock Register-CimIndicationEvent {
                return [PSCustomObject]@{ Name = 'MockJob' }
            } -ModuleName FFU.Hypervisor

            Mock Unregister-Event { } -ModuleName FFU.Hypervisor
            Mock Remove-Job { } -ModuleName FFU.Hypervisor
        }

        It "Should register CIM event with correct namespace" {
            # Short timeout to avoid long test
            $result = Wait-VMStateChange -VMName 'TestVM' -TargetState 'Off' -TimeoutSeconds 1

            Should -Invoke Register-CimIndicationEvent -ModuleName FFU.Hypervisor -ParameterFilter {
                $Namespace -eq 'root\virtualization\v2'
            }
        }

        It "Should include VM name in WQL query" {
            $result = Wait-VMStateChange -VMName 'TestVM' -TargetState 'Off' -TimeoutSeconds 1

            Should -Invoke Register-CimIndicationEvent -ModuleName FFU.Hypervisor -ParameterFilter {
                $Query -match 'TestVM'
            }
        }
    }

    Context "Cleanup" {

        BeforeEach {
            Mock Get-VM {
                return [PSCustomObject]@{ Name = 'TestVM'; State = 'Running' }
            } -ModuleName FFU.Hypervisor

            Mock Register-CimIndicationEvent {
                return [PSCustomObject]@{ Name = 'MockJob' }
            } -ModuleName FFU.Hypervisor

            Mock Unregister-Event { } -ModuleName FFU.Hypervisor
            Mock Remove-Job { } -ModuleName FFU.Hypervisor
        }

        It "Should unregister event subscription on timeout" {
            $result = Wait-VMStateChange -VMName 'TestVM' -TargetState 'Off' -TimeoutSeconds 1

            Should -Invoke Unregister-Event -ModuleName FFU.Hypervisor -Times 1
        }

        It "Should clean up job on timeout" {
            $result = Wait-VMStateChange -VMName 'TestVM' -TargetState 'Off' -TimeoutSeconds 1

            Should -Invoke Remove-Job -ModuleName FFU.Hypervisor -Times 1
        }
    }

    Context "State Mapping" {

        BeforeEach {
            Mock Register-CimIndicationEvent { } -ModuleName FFU.Hypervisor
            Mock Unregister-Event { } -ModuleName FFU.Hypervisor
            Mock Remove-Job { } -ModuleName FFU.Hypervisor
        }

        It "Should accept 'Running' as valid target state" {
            Mock Get-VM { [PSCustomObject]@{ Name = 'TestVM'; State = 'Running' } } -ModuleName FFU.Hypervisor

            { Wait-VMStateChange -VMName 'TestVM' -TargetState 'Running' -TimeoutSeconds 1 } | Should -Not -Throw
        }

        It "Should accept 'Off' as valid target state" {
            Mock Get-VM { [PSCustomObject]@{ Name = 'TestVM'; State = 'Off' } } -ModuleName FFU.Hypervisor

            { Wait-VMStateChange -VMName 'TestVM' -TargetState 'Off' -TimeoutSeconds 1 } | Should -Not -Throw
        }

        It "Should accept 'Paused' as valid target state" {
            Mock Get-VM { [PSCustomObject]@{ Name = 'TestVM'; State = 'Paused' } } -ModuleName FFU.Hypervisor

            { Wait-VMStateChange -VMName 'TestVM' -TargetState 'Paused' -TimeoutSeconds 1 } | Should -Not -Throw
        }

        It "Should reject invalid target states" {
            { Wait-VMStateChange -VMName 'TestVM' -TargetState 'InvalidState' -TimeoutSeconds 1 } | Should -Throw
        }
    }
}

Describe "HyperVProvider.WaitForState Integration" {

    It "Should have WaitForState method in HyperVProvider" {
        $providerContent = Get-Content (Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.Hypervisor\Providers\HyperVProvider.ps1") -Raw

        $providerContent | Should -Match "WaitForState"
    }

    It "Should export Wait-VMStateChange function" {
        Get-Command Wait-VMStateChange -Module FFU.Hypervisor -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty
    }
}
```
  </action>
  <verify>
Run the tests:
```powershell
Invoke-Pester -Path "Tests/Unit/FFU.Hypervisor.EventDriven.Tests.ps1" -Output Detailed
```
All tests should pass.
  </verify>
  <done>10+ Pester tests pass covering CIM event registration, state mapping, cleanup, and integration</done>
</task>

</tasks>

<verification>
1. Module imports without error:
   ```powershell
   Import-Module "FFUDevelopment\Modules\FFU.Hypervisor" -Force -Verbose
   ```

2. Wait-VMStateChange is exported:
   ```powershell
   Get-Command Wait-VMStateChange -Module FFU.Hypervisor
   ```

3. CIM event pattern is used:
   ```powershell
   Select-String -Path "FFUDevelopment\Modules\FFU.Hypervisor\Public\Wait-VMStateChange.ps1" -Pattern "Register-CimIndicationEvent"
   ```

4. All tests pass:
   ```powershell
   Invoke-Pester -Path "Tests/Unit/FFU.Hypervisor*.Tests.ps1" -Output Detailed
   ```
</verification>

<success_criteria>
- [ ] Wait-VMStateChange function created using Register-CimIndicationEvent
- [ ] HyperVProvider has WaitForState method using new function
- [ ] Event subscription cleanup in finally block (no leaks)
- [ ] Module version incremented with release notes
- [ ] Function exported from FFU.Hypervisor module
- [ ] 6+ Pester tests pass for event-driven monitoring
- [ ] Existing FFU.Hypervisor tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-optimization/04-02-SUMMARY.md`
</output>
