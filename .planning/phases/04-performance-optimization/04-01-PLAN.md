---
phase: 04-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psm1
  - FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psd1
  - Tests/Unit/FFU.Imaging.VolumeFlush.Tests.ps1
autonomous: true

must_haves:
  truths:
    - "VHD dismount uses single verified flush instead of triple-pass"
    - "Write-VolumeCache is used when available"
    - "fsutil fallback exists for older Windows"
    - "Flush completes in <2 seconds (down from ~7 seconds)"
  artifacts:
    - path: "FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psm1"
      provides: "Invoke-VerifiedVolumeFlush function with Write-VolumeCache"
      contains: "Write-VolumeCache"
    - path: "Tests/Unit/FFU.Imaging.VolumeFlush.Tests.ps1"
      provides: "Pester tests for volume flush optimization"
      min_tests: 8
  key_links:
    - from: "Dismount-ScratchVhd"
      to: "Invoke-VerifiedVolumeFlush"
      via: "Function call replacing triple-pass loop"
      pattern: "Invoke-VerifiedVolumeFlush"
---

<objective>
Replace triple-pass VHD flush with single verified Write-VolumeCache call

Purpose: Reduce VHD dismount time by 50%+ while maintaining data integrity. Current implementation does 3 flush passes with 500ms pauses + 5s final wait (~7s total). Write-VolumeCache provides guaranteed flush in a single call (<1s).

Output: Optimized Dismount-ScratchVhd function using Write-VolumeCache with fsutil fallback
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/04-performance-optimization/04-RESEARCH.md

Key files:
- FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psm1 (lines 1143-1193 - current flush implementation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Invoke-VerifiedVolumeFlush helper function</name>
  <files>FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psm1</files>
  <action>
Add new private helper function `Invoke-VerifiedVolumeFlush` before Dismount-ScratchVhd (around line 1100):

```powershell
function Invoke-VerifiedVolumeFlush {
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory)]
        [string]$VhdPath
    )

    WriteLog "Flushing file system buffers before VHD dismount..."

    try {
        # Find all volumes on this VHD by matching the disk path
        $disk = Get-Disk -ErrorAction SilentlyContinue | Where-Object {
            $_.BusType -eq 'File Backed Virtual' -and $_.Location -eq $VhdPath
        }

        if (-not $disk) {
            WriteLog "  Could not identify VHD disk for targeted flush, using fallback..."
            return Invoke-FallbackVolumeFlush
        }

        $partitions = $disk | Get-Partition -ErrorAction SilentlyContinue | Where-Object { $_.DriveLetter }

        if (-not $partitions) {
            WriteLog "  No partitions with drive letters found"
            return $true  # Nothing to flush
        }

        # Check if Write-VolumeCache is available (Windows 10+/Server 2016+)
        $writeVolumeCacheAvailable = Get-Command Write-VolumeCache -Module Storage -ErrorAction SilentlyContinue

        if ($writeVolumeCacheAvailable) {
            # Use native cmdlet - single verified flush operation
            foreach ($partition in $partitions) {
                $driveLetter = $partition.DriveLetter
                WriteLog "  Flushing volume $driveLetter`: (Write-VolumeCache)..."
                Write-VolumeCache -DriveLetter $driveLetter -ErrorAction Stop
                WriteLog "    Volume $driveLetter`: flushed (verified)"
            }
        }
        else {
            # Fallback to fsutil for older Windows versions
            WriteLog "  Write-VolumeCache not available, using fsutil fallback..."
            foreach ($partition in $partitions) {
                $driveLetter = $partition.DriveLetter
                WriteLog "  Flushing volume $driveLetter`: (fsutil)..."
                $flushResult = & fsutil volume flush "$driveLetter`:" 2>&1
                if ($LASTEXITCODE -eq 0) {
                    WriteLog "    Volume $driveLetter`: flushed"
                }
                else {
                    WriteLog "    WARNING: fsutil flush returned: $flushResult"
                }
            }
        }

        WriteLog "Volume flush complete"
        return $true
    }
    catch {
        WriteLog "WARNING: Volume flush encountered error: $($_.Exception.Message)"
        WriteLog "Continuing with dismount anyway..."
        return $false
    }
}

function Invoke-FallbackVolumeFlush {
    # Fallback: flush all fixed/removable volumes when VHD disk cannot be identified
    WriteLog "  Flushing all fixed/removable volumes as fallback..."
    Get-Volume -ErrorAction SilentlyContinue | Where-Object {
        $_.DriveType -in @('Fixed', 'Removable') -and $_.DriveLetter
    } | ForEach-Object {
        $null = & fsutil volume flush "$($_.DriveLetter):" 2>&1
    }
    return $true
}
```

Do NOT remove the old code yet - that's Task 2.
  </action>
  <verify>
Function added to FFU.Imaging.psm1:
```powershell
Import-Module "$PSScriptRoot\FFUDevelopment\Modules\FFU.Imaging" -Force
Get-Command Invoke-VerifiedVolumeFlush -ErrorAction SilentlyContinue
```
  </verify>
  <done>Invoke-VerifiedVolumeFlush function exists in FFU.Imaging.psm1 with Write-VolumeCache primary path and fsutil fallback</done>
</task>

<task type="auto">
  <name>Task 2: Replace triple-pass flush in Dismount-ScratchVhd</name>
  <files>FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psm1, FFUDevelopment/Modules/FFU.Imaging/FFU.Imaging.psd1</files>
  <action>
In Dismount-ScratchVhd function (around lines 1143-1193), replace the entire flush block:

**REMOVE this block** (the triple-pass flush loop with 500ms pauses and 5s final wait):
```powershell
    # CRITICAL: Flush all file system buffers before detaching the VHD
    # ... through ...
    WriteLog "Volume flush complete"
```

**REPLACE with:**
```powershell
    # CRITICAL: Flush all file system buffers before detaching the VHD
    # This ensures all pending writes (including unattend.xml) are committed to the VHD file
    # Without this flush, data may be lost when using diskpart detach (unlike Dismount-VHD which flushes automatically)
    $flushSuccess = Invoke-VerifiedVolumeFlush -VhdPath $VhdPath

    if (-not $flushSuccess) {
        WriteLog "WARNING: Volume flush may not have completed successfully"
        # Brief pause as safety margin when flush reports issues
        Start-Sleep -Seconds 2
    }
```

This removes:
- 3x flush passes with 500ms pauses between each (1.5s)
- 5s final "Waiting for disk I/O to complete" delay
- Approximately 6.5+ seconds of wait time

The Write-VolumeCache cmdlet guarantees completion before returning, so no additional waits are needed.

**Update module manifest** (FFU.Imaging.psd1):
- Increment ModuleVersion to next patch (check current version first)
- Add release note: "v{version} - Optimize VHD flush from triple-pass to single verified Write-VolumeCache call (~7s -> <1s)"
  </action>
  <verify>
1. Grep for triple-pass should return nothing:
```powershell
Select-String -Path "FFUDevelopment\Modules\FFU.Imaging\FFU.Imaging.psm1" -Pattern "Flush pass.*of 3"
```
Should return empty.

2. New function call should exist:
```powershell
Select-String -Path "FFUDevelopment\Modules\FFU.Imaging\FFU.Imaging.psm1" -Pattern "Invoke-VerifiedVolumeFlush"
```
Should return the call in Dismount-ScratchVhd.
  </verify>
  <done>Dismount-ScratchVhd uses single Invoke-VerifiedVolumeFlush call, module version updated</done>
</task>

<task type="auto">
  <name>Task 3: Add Pester tests for volume flush optimization</name>
  <files>Tests/Unit/FFU.Imaging.VolumeFlush.Tests.ps1</files>
  <action>
Create new test file `Tests/Unit/FFU.Imaging.VolumeFlush.Tests.ps1`:

```powershell
#Requires -Modules Pester

<#
.SYNOPSIS
    Pester tests for FFU.Imaging volume flush optimization (PERF-01)

.DESCRIPTION
    Tests Invoke-VerifiedVolumeFlush function behavior including:
    - Write-VolumeCache usage when available
    - fsutil fallback for older Windows
    - Error handling and graceful degradation
    - Correct VHD disk identification
#>

BeforeAll {
    # Import module under test
    $modulePath = Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.Imaging"
    Import-Module $modulePath -Force -ErrorAction Stop

    # Mock WriteLog to avoid output during tests
    Mock WriteLog { } -ModuleName FFU.Imaging
}

Describe "Invoke-VerifiedVolumeFlush" {

    Context "When Write-VolumeCache is available" {

        BeforeEach {
            # Mock Get-Command to indicate Write-VolumeCache exists
            Mock Get-Command {
                return [PSCustomObject]@{ Name = 'Write-VolumeCache' }
            } -ModuleName FFU.Imaging -ParameterFilter { $Name -eq 'Write-VolumeCache' }

            # Mock Get-Disk to return a virtual disk
            Mock Get-Disk {
                return [PSCustomObject]@{
                    BusType = 'File Backed Virtual'
                    Location = 'C:\Test\test.vhd'
                    Number = 1
                }
            } -ModuleName FFU.Imaging

            # Mock Get-Partition to return partition with drive letter
            Mock Get-Partition {
                return [PSCustomObject]@{ DriveLetter = 'Z' }
            } -ModuleName FFU.Imaging

            # Mock Write-VolumeCache
            Mock Write-VolumeCache { } -ModuleName FFU.Imaging
        }

        It "Should use Write-VolumeCache for flush" {
            $result = Invoke-VerifiedVolumeFlush -VhdPath 'C:\Test\test.vhd'

            Should -Invoke Write-VolumeCache -ModuleName FFU.Imaging -Times 1 -Exactly
            $result | Should -Be $true
        }

        It "Should NOT use fsutil when Write-VolumeCache available" {
            Mock fsutil { } -ModuleName FFU.Imaging

            $result = Invoke-VerifiedVolumeFlush -VhdPath 'C:\Test\test.vhd'

            Should -Invoke fsutil -ModuleName FFU.Imaging -Times 0
        }

        It "Should flush all partitions with drive letters" {
            Mock Get-Partition {
                return @(
                    [PSCustomObject]@{ DriveLetter = 'X' },
                    [PSCustomObject]@{ DriveLetter = 'Y' },
                    [PSCustomObject]@{ DriveLetter = $null }  # EFI partition - no letter
                )
            } -ModuleName FFU.Imaging

            $result = Invoke-VerifiedVolumeFlush -VhdPath 'C:\Test\test.vhd'

            # Should call Write-VolumeCache twice (X and Y, not null)
            Should -Invoke Write-VolumeCache -ModuleName FFU.Imaging -Times 2 -Exactly
        }
    }

    Context "When Write-VolumeCache is NOT available (fallback)" {

        BeforeEach {
            # Mock Get-Command to indicate Write-VolumeCache does NOT exist
            Mock Get-Command { return $null } -ModuleName FFU.Imaging -ParameterFilter {
                $Name -eq 'Write-VolumeCache'
            }

            Mock Get-Disk {
                return [PSCustomObject]@{
                    BusType = 'File Backed Virtual'
                    Location = 'C:\Test\test.vhd'
                    Number = 1
                }
            } -ModuleName FFU.Imaging

            Mock Get-Partition {
                return [PSCustomObject]@{ DriveLetter = 'Z' }
            } -ModuleName FFU.Imaging

            # Mock fsutil command
            Mock fsutil { $global:LASTEXITCODE = 0; return "Success" } -ModuleName FFU.Imaging
        }

        It "Should use fsutil as fallback" {
            $result = Invoke-VerifiedVolumeFlush -VhdPath 'C:\Test\test.vhd'

            Should -Invoke fsutil -ModuleName FFU.Imaging -Times 1
            $result | Should -Be $true
        }
    }

    Context "When VHD disk cannot be identified" {

        BeforeEach {
            Mock Get-Disk { return $null } -ModuleName FFU.Imaging
            Mock Get-Volume {
                return @(
                    [PSCustomObject]@{ DriveType = 'Fixed'; DriveLetter = 'C' },
                    [PSCustomObject]@{ DriveType = 'Fixed'; DriveLetter = 'D' }
                )
            } -ModuleName FFU.Imaging
            Mock fsutil { $global:LASTEXITCODE = 0 } -ModuleName FFU.Imaging
        }

        It "Should use fallback flush for all volumes" {
            $result = Invoke-VerifiedVolumeFlush -VhdPath 'C:\Test\test.vhd'

            # Should call fsutil for each fixed volume
            Should -Invoke fsutil -ModuleName FFU.Imaging -Times 2
        }
    }

    Context "Error handling" {

        It "Should return false and continue when flush fails" {
            Mock Get-Disk { throw "Disk access error" } -ModuleName FFU.Imaging

            $result = Invoke-VerifiedVolumeFlush -VhdPath 'C:\Test\test.vhd'

            $result | Should -Be $false
        }

        It "Should return true when no partitions have drive letters" {
            Mock Get-Disk {
                return [PSCustomObject]@{
                    BusType = 'File Backed Virtual'
                    Location = 'C:\Test\test.vhd'
                }
            } -ModuleName FFU.Imaging
            Mock Get-Partition {
                return [PSCustomObject]@{ DriveLetter = $null }
            } -ModuleName FFU.Imaging

            $result = Invoke-VerifiedVolumeFlush -VhdPath 'C:\Test\test.vhd'

            $result | Should -Be $true
        }
    }
}

Describe "Dismount-ScratchVhd Integration" {

    It "Should NOT contain triple-pass flush loop" {
        $moduleContent = Get-Content (Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.Imaging\FFU.Imaging.psm1") -Raw

        $moduleContent | Should -Not -Match "Flush pass .* of 3"
        $moduleContent | Should -Not -Match "for \(\`$flushPass = 1"
    }

    It "Should call Invoke-VerifiedVolumeFlush" {
        $moduleContent = Get-Content (Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.Imaging\FFU.Imaging.psm1") -Raw

        $moduleContent | Should -Match "Invoke-VerifiedVolumeFlush"
    }
}
```
  </action>
  <verify>
Run the new tests:
```powershell
Invoke-Pester -Path "Tests/Unit/FFU.Imaging.VolumeFlush.Tests.ps1" -Output Detailed
```
All tests should pass.
  </verify>
  <done>8+ Pester tests pass covering Write-VolumeCache usage, fsutil fallback, error handling, and integration verification</done>
</task>

</tasks>

<verification>
1. Module imports without error:
   ```powershell
   Import-Module "FFUDevelopment\Modules\FFU.Imaging" -Force -Verbose
   ```

2. No triple-pass flush in code:
   ```powershell
   Select-String -Path "FFUDevelopment\Modules\FFU.Imaging\FFU.Imaging.psm1" -Pattern "Flush pass|flushPass"
   ```
   Should return empty.

3. Write-VolumeCache is primary flush method:
   ```powershell
   Select-String -Path "FFUDevelopment\Modules\FFU.Imaging\FFU.Imaging.psm1" -Pattern "Write-VolumeCache"
   ```
   Should return at least one match.

4. All tests pass:
   ```powershell
   Invoke-Pester -Path "Tests/Unit/FFU.Imaging*.Tests.ps1" -Output Detailed
   ```
</verification>

<success_criteria>
- [ ] Invoke-VerifiedVolumeFlush function created with Write-VolumeCache + fsutil fallback
- [ ] Dismount-ScratchVhd uses single verified flush call instead of triple-pass loop
- [ ] 5+ second wait time removed from VHD dismount path
- [ ] Module version incremented with release notes
- [ ] 8+ Pester tests pass for flush optimization
- [ ] Existing FFU.Imaging tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-optimization/04-01-SUMMARY.md`
</output>
