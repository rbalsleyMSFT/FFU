---
phase: 12-vhdx-drive-letter
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - FFUDevelopment/BuildFFUVM.ps1
  - FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1
  - FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Invoke-MountScratchDisk guarantees drive letter after mount"
    - "Drive letter persists through unattend file copy workflow"
    - "Hyper-V provider returns valid drive letter from MountVirtualDisk"
    - "VMware provider returns valid drive letter from MountVirtualDisk"
  artifacts:
    - path: "FFUDevelopment/BuildFFUVM.ps1"
      provides: "Invoke-MountScratchDisk with guaranteed drive letter"
      contains: "Set-OSPartitionDriveLetter"
    - path: "FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1"
      provides: "HyperV MountVirtualDisk with verified drive letter"
      contains: "MountVirtualDisk"
    - path: "FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1"
      provides: "VMware MountVirtualDisk with verified drive letter"
      contains: "MountVirtualDisk"
  key_links:
    - from: "BuildFFUVM.ps1 Invoke-MountScratchDisk"
      to: "FFU.Imaging Set-OSPartitionDriveLetter"
      via: "function call after mount"
      pattern: "Set-OSPartitionDriveLetter"
    - from: "HyperVProvider MountVirtualDisk"
      to: "Set-Partition"
      via: "drive letter assignment"
      pattern: "Set-Partition.*-NewDriveLetter"
---

<objective>
Integrate Set-OSPartitionDriveLetter into mount operations to guarantee drive letter stability across dismount/remount cycles.

Purpose: The existing drive letter workaround at BuildFFUVM.ps1 lines 4226-4253 only handles the unattend injection section. This plan ensures ALL mount operations guarantee a drive letter by calling the centralized utility function immediately after mounting.

Output: All mount paths (Invoke-MountScratchDisk for both VHD/VHDX) guarantee drive letter assignment. Both Hyper-V and VMware providers verified to return valid drive letters.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-vhdx-drive-letter/12-RESEARCH.md
@.planning/phases/12-vhdx-drive-letter/12-01-SUMMARY.md

# Files to modify
@FFUDevelopment/BuildFFUVM.ps1 (lines 1163-1260 for Invoke-MountScratchDisk)
@FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1 (lines 411-442 for MountVirtualDisk)
@FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1 (lines 760-770 for MountVirtualDisk)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate Set-OSPartitionDriveLetter into Invoke-MountScratchDisk</name>
  <files>FFUDevelopment/BuildFFUVM.ps1</files>
  <action>
Modify Invoke-MountScratchDisk function (lines 1163-1260) to call Set-OSPartitionDriveLetter after mounting and store the guaranteed drive letter.

Changes:
1. After the disk is mounted (both VHD and VHDX paths), call Set-OSPartitionDriveLetter
2. Store the returned drive letter on the disk object or return it separately
3. Log the guaranteed drive letter for debugging

Current function returns just the disk object. Add a property or modify return to include drive letter.

Option A - Add NoteProperty to disk object:
```powershell
# After mount completes and $disk is available:
$driveLetter = Set-OSPartitionDriveLetter -Disk $disk -PreferredLetter 'W'
$disk | Add-Member -NotePropertyName 'OSPartitionDriveLetter' -NotePropertyValue $driveLetter -Force
WriteLog "Mounted scratch disk with guaranteed drive letter: $driveLetter"
return $disk
```

Option B - Return hashtable (breaking change - evaluate impact):
This would require updating all call sites, which is more invasive.

**Recommendation: Use Option A** - maintains backward compatibility while providing drive letter access.

Apply to BOTH code paths:
1. VHD path (diskpart-based mount) - around line 1220
2. VHDX path (Mount-VHD cmdlet) - around line 1250

Note: The existing workaround at lines 4226-4253 can remain as defensive code, but will now rarely be needed since Invoke-MountScratchDisk guarantees the drive letter.
  </action>
  <verify>
```powershell
# Verify Set-OSPartitionDriveLetter is called in Invoke-MountScratchDisk
$content = Get-Content "FFUDevelopment/BuildFFUVM.ps1" -Raw
$content -match 'Set-OSPartitionDriveLetter.*-Disk \$disk' | Should -Be $true
$content -match 'OSPartitionDriveLetter' | Should -Be $true
```
  </verify>
  <done>Invoke-MountScratchDisk calls Set-OSPartitionDriveLetter and attaches drive letter to disk object</done>
</task>

<task type="auto">
  <name>Task 2: Verify Hyper-V provider MountVirtualDisk drive letter handling</name>
  <files>FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1</files>
  <action>
Review and enhance HyperVProvider.MountVirtualDisk (lines 411-442) to ensure robust drive letter handling.

The current implementation already attempts to assign a drive letter if none exists. Verify it:
1. Returns a valid drive letter string (not null or empty)
2. Logs the assigned drive letter for debugging
3. Throws clear exception if assignment fails

Current code analysis (lines 411-436):
- Mounts VHD and gets partitions
- Returns existing drive letter if found
- Assigns available letter if none found
- Returns drive letter path string like "W:\"

Enhancement needed:
1. Add verification that the returned drive letter path is actually accessible:
```powershell
$drivePath = "$($partition.DriveLetter):\"
if (-not (Test-Path $drivePath)) {
    WriteLog "WARNING: Drive letter assigned but path not accessible, waiting..."
    Start-Sleep -Milliseconds 500
    if (-not (Test-Path $drivePath)) {
        throw "Drive letter $($partition.DriveLetter) assigned but path not accessible"
    }
}
```

2. Add retry logic for transient assignment failures (match FFU.Imaging pattern)

3. Add logging before return showing final drive letter
  </action>
  <verify>
```powershell
# Verify HyperVProvider has drive letter verification
$content = Get-Content "FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1" -Raw
$content -match 'Test-Path.*\$drivePath' | Should -Be $true
$content -match 'MountVirtualDisk.*return.*:\\' | Should -Be $true
```
  </verify>
  <done>HyperV provider MountVirtualDisk verified to return accessible drive letter with validation</done>
</task>

<task type="auto">
  <name>Task 3: Verify VMware provider MountVirtualDisk drive letter handling</name>
  <files>FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1</files>
  <action>
Review and enhance VMwareProvider.MountVirtualDisk (lines 760-770) to ensure robust drive letter handling.

Current implementation delegates to Mount-VHDWithDiskpart which handles drive letter internally. Verify the chain:
1. Mount-VHDWithDiskpart mounts VHD via diskpart
2. Get-VHDMountedDriveLetter detects drive letter
3. Set-VHDDriveLetter assigns if missing

Enhancement needed:
1. Add verification that returned drive letter is valid and accessible:
```powershell
[string] MountVirtualDisk([string]$Path) {
    try {
        $driveLetter = Mount-VHDWithDiskpart -Path $Path

        # Verify drive letter is not empty
        if ([string]::IsNullOrWhiteSpace($driveLetter)) {
            throw "Mount-VHDWithDiskpart returned empty drive letter"
        }

        # Verify path is accessible
        if (-not (Test-Path $driveLetter)) {
            WriteLog "WARNING: Drive letter returned but path not accessible, waiting..."
            Start-Sleep -Milliseconds 500
            if (-not (Test-Path $driveLetter)) {
                throw "Drive letter $driveLetter assigned but path not accessible"
            }
        }

        WriteLog "Mounted virtual disk $Path at $driveLetter"
        return $driveLetter
    }
    catch {
        WriteLog "ERROR: Failed to mount virtual disk: $($_.Exception.Message)"
        throw
    }
}
```

2. Ensure consistent drive letter format (e.g., "W:" or "W:\")
  </action>
  <verify>
```powershell
# Verify VMwareProvider has drive letter verification
$content = Get-Content "FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1" -Raw
$content -match 'Test-Path.*\$driveLetter' | Should -Be $true
$content -match 'IsNullOrWhiteSpace.*driveLetter' | Should -Be $true
```
  </verify>
  <done>VMware provider MountVirtualDisk verified to return accessible drive letter with validation</done>
</task>

</tasks>

<verification>
1. BuildFFUVM.ps1 integrates Set-OSPartitionDriveLetter:
```powershell
$content = Get-Content "FFUDevelopment/BuildFFUVM.ps1" -Raw
$content -match 'Set-OSPartitionDriveLetter' | Should -Be $true
```

2. Providers validate drive letter accessibility:
```powershell
$hyper = Get-Content "FFUDevelopment/Modules/FFU.Hypervisor/Providers/HyperVProvider.ps1" -Raw
$vmware = Get-Content "FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1" -Raw
$hyper -match 'Test-Path' | Should -Be $true
$vmware -match 'Test-Path' | Should -Be $true
```

3. All module imports work:
```powershell
Import-Module "FFUDevelopment/Modules/FFU.Imaging" -Force -ErrorAction Stop
Import-Module "FFUDevelopment/Modules/FFU.Hypervisor" -Force -ErrorAction Stop
```

4. Existing tests still pass:
```powershell
$result = Invoke-Pester -Path "Tests/Unit/FFU.Imaging*.Tests.ps1" -PassThru
$result.FailedCount | Should -Be 0
```
</verification>

<success_criteria>
- [ ] Invoke-MountScratchDisk calls Set-OSPartitionDriveLetter after mount
- [ ] Disk object returned has OSPartitionDriveLetter property
- [ ] HyperVProvider.MountVirtualDisk validates drive letter accessibility
- [ ] VMwareProvider.MountVirtualDisk validates drive letter accessibility
- [ ] Both providers throw clear exceptions on drive letter failure
- [ ] Existing workaround at lines 4226-4253 remains as defensive backup
- [ ] All modules import successfully
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-vhdx-drive-letter/12-02-SUMMARY.md`
</output>
