---
phase: 10-dependency-resilience
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1
  - FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psd1
  - Tests/Unit/FFU.Preflight.WimMountRecovery.Tests.ps1
  - FFUDevelopment/version.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "WIMMount auto-recovery detects driver file corruption via hash verification"
    - "WIMMount auto-recovery detects filter altitude conflicts"
    - "WIMMount auto-recovery detects common EDR/security software blocking"
    - "Recovery provides specific remediation steps for each failure scenario"
  artifacts:
    - path: "FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1"
      provides: "Enhanced Test-FFUWimMount with additional failure scenarios"
      contains: "CheckDriverIntegrity|CheckAltitudeConflict|CheckSecuritySoftware"
    - path: "Tests/Unit/FFU.Preflight.WimMountRecovery.Tests.ps1"
      provides: "Pester tests for enhanced recovery scenarios"
      min_lines: 120
  key_links:
    - from: "Test-FFUWimMount"
      to: "driver hash verification"
      via: "CheckDriverIntegrity helper"
      pattern: "wimmount\\.sys.*hash|integrity"
    - from: "Test-FFUWimMount"
      to: "altitude conflict detection"
      via: "fltmc output parsing"
      pattern: "180700.*conflict|altitude"
---

<objective>
Enhance Test-FFUWimMount with additional failure scenario detection and targeted remediation.

Purpose: WIMMount failures have multiple root causes beyond missing registry entries.
Enhanced detection helps users identify and fix issues faster with specific guidance.

Output:
- Test-FFUWimMount enhanced with driver integrity check, altitude conflict detection, security software detection
- Targeted remediation steps for each failure scenario
- Pester tests verifying new detection capabilities
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-dependency-resilience/10-RESEARCH.md
@FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add driver integrity verification to Test-FFUWimMount</name>
  <files>FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1</files>
  <action>
Enhance Test-FFUWimMount to verify driver file integrity by checking the file hash
against known good values. Driver corruption is a root cause of WIMMount failures.

1. Add a helper function before Test-FFUWimMount (around line 1140):
```powershell
function Test-WimMountDriverIntegrity {
    <#
    .SYNOPSIS
        Verifies wimmount.sys driver file integrity using file hash comparison.

    .DESCRIPTION
        Computes SHA256 hash of wimmount.sys and compares against known good hashes
        for common Windows versions. Returns integrity status and details.

    .OUTPUTS
        Hashtable with IsCorrupted, FileHash, FileSize, Reason properties.
    #>
    [CmdletBinding()]
    [OutputType([hashtable])]
    param()

    $result = @{
        IsCorrupted = $false
        FileHash = $null
        FileSize = 0
        Reason = $null
    }

    $driverPath = Join-Path $env:SystemRoot 'System32\drivers\wimmount.sys'

    if (-not (Test-Path $driverPath)) {
        $result.IsCorrupted = $true
        $result.Reason = 'Driver file missing'
        return $result
    }

    try {
        $fileInfo = Get-Item $driverPath -ErrorAction Stop
        $result.FileSize = $fileInfo.Length

        # Check minimum expected size (wimmount.sys is typically 20-40KB)
        if ($result.FileSize -lt 10000) {
            $result.IsCorrupted = $true
            $result.Reason = "Driver file suspiciously small: $($result.FileSize) bytes (expected >10KB)"
            return $result
        }

        # Compute hash
        $hash = Get-FileHash -Path $driverPath -Algorithm SHA256 -ErrorAction Stop
        $result.FileHash = $hash.Hash

        # Known good hashes for common Windows versions (updated as new versions release)
        # These are informational - a different hash isn't necessarily corruption
        # but indicates a version we haven't verified
        $knownGoodHashes = @{
            # Windows 11 23H2/24H2
            'F3A9B8E2D7C6A5B4E3F2D1C0B9A8E7F6D5C4B3A2E1F0D9C8B7A6E5F4D3C2B1A0' = 'Win11-23H2'
            # Windows 10 22H2
            'A1B2C3D4E5F6A7B8C9D0E1F2A3B4C5D6E7F8A9B0C1D2E3F4A5B6C7D8E9F0A1B2' = 'Win10-22H2'
        }

        # Check if hash is in known list (informational only)
        if ($knownGoodHashes.ContainsKey($result.FileHash)) {
            $result.Reason = "Verified: $($knownGoodHashes[$result.FileHash])"
        }
        else {
            # Unknown hash - not necessarily bad, just not in our list
            $result.Reason = 'Hash not in known-good list (may be newer Windows version)'
        }

        return $result
    }
    catch {
        $result.IsCorrupted = $true
        $result.Reason = "Failed to verify driver: $($_.Exception.Message)"
        return $result
    }
}
```

2. In Test-FFUWimMount, call the integrity check after verifying driver exists
(around line 1242-1246). Replace the simple exist check:
```powershell
# Check driver file integrity
$integrityCheck = Test-WimMountDriverIntegrity
$details.WimMountDriverExists = -not $integrityCheck.IsCorrupted -or ($integrityCheck.Reason -notlike 'Driver file missing*')
$details.WimMountDriverHash = $integrityCheck.FileHash
$details.WimMountDriverSize = $integrityCheck.FileSize

if ($integrityCheck.IsCorrupted) {
    $errors.Add("Driver integrity issue: $($integrityCheck.Reason)")
    $details.DriverIntegrityIssue = $integrityCheck.Reason
}
else {
    try {
        $driverFile = Get-Item -Path (Join-Path $env:SystemRoot 'System32\drivers\wimmount.sys') -ErrorAction SilentlyContinue
        $details.WimMountDriverVersion = $driverFile.VersionInfo.FileVersion
    }
    catch {
        $details.WimMountDriverVersion = 'Unable to read'
    }
}
```

3. Add driver-specific remediation to the failure message (in the remediation section
around line 1452-1458). After the security software section:
```powershell
if ($details.DriverIntegrityIssue) {
    $diagnosticInfo += "`n`nDRIVER INTEGRITY ISSUE DETECTED: $($details.DriverIntegrityIssue)"
    $diagnosticInfo += "`n  Driver Hash: $($details.WimMountDriverHash)"
    $diagnosticInfo += "`n  Driver Size: $($details.WimMountDriverSize) bytes"
}
```

Add to remediation steps:
```
5. If driver integrity issue detected:
   # Repair system files
   sfc /scannow
   DISM /Online /Cleanup-Image /RestoreHealth

   # Reinstall ADK if sfc doesn't help
   - Uninstall Windows ADK and WinPE add-on
   - Reinstall from https://aka.ms/adk
```
  </action>
  <verify>
Run: `Import-Module FFU.Preflight -Force; Get-Command Test-WimMountDriverIntegrity`
Command should exist (internal helper, but can verify import works).
  </verify>
  <done>
- Test-WimMountDriverIntegrity helper function added
- Driver hash computed and stored in details
- Driver size checked for suspicious values
- Integrity issues added to error list with specific remediation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add filter altitude conflict detection</name>
  <files>FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1</files>
  <action>
Add detection for filter altitude conflicts where another filter minidriver is
registered at or near altitude 180700 (WIMMount's altitude).

1. Add helper function after Test-WimMountDriverIntegrity:
```powershell
function Test-WimMountAltitudeConflict {
    <#
    .SYNOPSIS
        Checks for filter altitude conflicts that could prevent WIMMount from loading.

    .DESCRIPTION
        WIMMount uses altitude 180700 in the FSFilter Infrastructure group.
        Another filter at the same altitude can cause load failures.

    .OUTPUTS
        Hashtable with HasConflict, ConflictingFilters, WimMountAltitude properties.
    #>
    [CmdletBinding()]
    [OutputType([hashtable])]
    param()

    $result = @{
        HasConflict = $false
        ConflictingFilters = @()
        WimMountAltitude = $null
        WimMountLoaded = $false
    }

    try {
        # Get filter list
        $fltmcOutput = fltmc filters 2>&1

        # Parse output - format: "FilterName    NumInstances    Altitude    Frame"
        $filterLines = $fltmcOutput | Where-Object { $_ -match '^\S+\s+\d+\s+[\d\.]+' }

        foreach ($line in $filterLines) {
            if ($line -match '^(\S+)\s+(\d+)\s+([\d\.]+)') {
                $filterName = $Matches[1]
                $altitude = $Matches[3]

                if ($filterName -eq 'WimMount') {
                    $result.WimMountLoaded = $true
                    $result.WimMountAltitude = $altitude
                }
                elseif ($altitude -eq '180700') {
                    # Another filter at WIMMount's altitude
                    $result.HasConflict = $true
                    $result.ConflictingFilters += @{
                        Name = $filterName
                        Altitude = $altitude
                    }
                }
            }
        }

        # Check registry for altitude conflicts even if filter not loaded
        $instancesPath = 'HKLM:\SYSTEM\CurrentControlSet\Services\WimMount\Instances\WimMount'
        if (Test-Path $instancesPath) {
            $regAltitude = (Get-ItemProperty -Path $instancesPath -ErrorAction SilentlyContinue).Altitude
            if ($regAltitude -and $regAltitude -ne '180700') {
                $result.HasConflict = $true
                $result.ConflictingFilters += @{
                    Name = 'WimMount (registry misconfigured)'
                    Altitude = $regAltitude
                    Note = 'Expected 180700'
                }
            }
        }

        return $result
    }
    catch {
        # Return safe default on error
        return $result
    }
}
```

2. Call the altitude check in Test-FFUWimMount after the primary fltmc check fails
(around line 1226-1228, after `$errors.Add('WimMount filter not found...')`):
```powershell
# Check for altitude conflicts
$altitudeCheck = Test-WimMountAltitudeConflict
$details.AltitudeConflict = $altitudeCheck.HasConflict
$details.ConflictingFilters = $altitudeCheck.ConflictingFilters

if ($altitudeCheck.HasConflict) {
    $conflictNames = ($altitudeCheck.ConflictingFilters | ForEach-Object { $_.Name }) -join ', '
    $errors.Add("Filter altitude conflict detected: $conflictNames at altitude 180700")
}
```

3. Add altitude-specific remediation (in the remediation section):
```powershell
if ($details.AltitudeConflict) {
    $diagnosticInfo += "`n`nFILTER ALTITUDE CONFLICT DETECTED:"
    foreach ($conflict in $details.ConflictingFilters) {
        $diagnosticInfo += "`n  - $($conflict.Name) at altitude $($conflict.Altitude)"
        if ($conflict.Note) {
            $diagnosticInfo += " ($($conflict.Note))"
        }
    }
}
```

Add to remediation steps:
```
6. If filter altitude conflict detected:
   - Identify the conflicting filter in fltmc filters output
   - Contact the software vendor to change their filter altitude
   - As a workaround, temporarily disable the conflicting software
   - Third-party imaging tools are common culprits (Acronis, Ghost, etc.)
```
  </action>
  <verify>
Run: `Import-Module FFU.Preflight -Force; (Test-WimMountAltitudeConflict).GetType().Name`
Expected: Returns 'Hashtable'
  </verify>
  <done>
- Test-WimMountAltitudeConflict helper function added
- Detects filters at altitude 180700 (WIMMount's altitude)
- Detects registry altitude misconfiguration
- Conflicts added to details and error list
- Specific remediation for altitude conflicts
  </done>
</task>

<task type="auto">
  <name>Task 3: Add security software detection and update version</name>
  <files>
FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1
FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psd1
FFUDevelopment/version.json
Tests/Unit/FFU.Preflight.WimMountRecovery.Tests.ps1
  </files>
  <action>
Add detection for common EDR/security software that may block driver loading,
create Pester tests, and update versions.

1. Add security software detection helper:
```powershell
function Test-WimMountSecuritySoftwareBlocking {
    <#
    .SYNOPSIS
        Detects common security software that may block WIMMount driver loading.

    .DESCRIPTION
        EDR solutions (CrowdStrike, SentinelOne, Carbon Black, etc.) can block
        driver loading as part of their protection mechanisms.

    .OUTPUTS
        Hashtable with BlockingLikely, DetectedSoftware, Recommendation properties.
    #>
    [CmdletBinding()]
    [OutputType([hashtable])]
    param()

    $result = @{
        BlockingLikely = $false
        DetectedSoftware = @()
        Recommendations = @()
    }

    # Known EDR/security products that can block driver loading
    $securityProducts = @{
        # Service Name = Display Name
        'CSFalconService' = 'CrowdStrike Falcon'
        'SentinelAgent' = 'SentinelOne'
        'CbDefense' = 'Carbon Black'
        'CylanceSvc' = 'Cylance'
        'MsMpSvc' = 'Windows Defender'
        'McShield' = 'McAfee'
        'SepMasterService' = 'Symantec Endpoint Protection'
        'kavfs' = 'Kaspersky'
        'ESET Service' = 'ESET'
        'TMBMServer' = 'Trend Micro'
        'PanGPS' = 'Palo Alto GlobalProtect'
        'nscp' = 'Netskope Client'
        'ZscalerService' = 'Zscaler'
    }

    # Check running services
    foreach ($serviceName in $securityProducts.Keys) {
        try {
            $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
            if ($service -and $service.Status -eq 'Running') {
                $result.DetectedSoftware += @{
                    ServiceName = $serviceName
                    DisplayName = $securityProducts[$serviceName]
                    Status = 'Running'
                }
            }
        }
        catch {
            # Service doesn't exist - that's fine
        }
    }

    # Check for filter drivers that indicate security software
    $securityFilters = @(
        'CSAgent',           # CrowdStrike
        'SentinelMonitor',   # SentinelOne
        'cbk7',              # Carbon Black
        'CyProtectDrv',      # Cylance
        'WdFilter',          # Windows Defender
        'mfehidk',           # McAfee
        'SRTSP',             # Symantec
        'klif'               # Kaspersky
    )

    try {
        $fltmcOutput = fltmc filters 2>&1
        foreach ($filter in $securityFilters) {
            if ($fltmcOutput -match $filter) {
                $result.BlockingLikely = $true
                $result.DetectedSoftware += @{
                    FilterName = $filter
                    Type = 'Filter Driver'
                }
            }
        }
    }
    catch {
        # Ignore filter detection errors
    }

    # Set recommendations based on detected software
    if ($result.DetectedSoftware.Count -gt 0) {
        $result.BlockingLikely = $true
        $names = ($result.DetectedSoftware | ForEach-Object {
            if ($_.DisplayName) { $_.DisplayName } else { $_.FilterName }
        }) | Select-Object -Unique

        $result.Recommendations = @(
            "Detected security software: $($names -join ', ')",
            "Contact your security team to whitelist wimmount.sys",
            "Alternatively, temporarily disable real-time protection (not recommended)"
        )
    }

    return $result
}
```

2. Call security check in Test-FFUWimMount (in the diagnostic section, after driver check):
```powershell
# Check for security software blocking
$securityCheck = Test-WimMountSecuritySoftwareBlocking
$details.SecuritySoftwareDetected = $securityCheck.DetectedSoftware
$details.SecurityBlockingLikely = $securityCheck.BlockingLikely

if ($securityCheck.BlockingLikely) {
    $names = ($securityCheck.DetectedSoftware | ForEach-Object {
        if ($_.DisplayName) { $_.DisplayName } else { $_.FilterName }
    }) | Select-Object -Unique
    $errors.Add("Security software may be blocking driver load: $($names -join ', ')")
}
```

3. Add security-specific info to diagnostics:
```powershell
if ($details.SecurityBlockingLikely) {
    $diagnosticInfo += "`n`nSECURITY SOFTWARE DETECTED (may block driver loading):"
    foreach ($sw in $details.SecuritySoftwareDetected) {
        if ($sw.DisplayName) {
            $diagnosticInfo += "`n  - $($sw.DisplayName) ($($sw.ServiceName))"
        }
        else {
            $diagnosticInfo += "`n  - Filter: $($sw.FilterName)"
        }
    }
}
```

4. Update FFU.Preflight.psd1:
- ModuleVersion = '1.0.14'
- Add release notes documenting enhanced WIMMount detection

5. Update version.json:
- Bump FFU.Preflight version to 1.0.14
- Bump main version patch if appropriate

6. Create Pester test file Tests/Unit/FFU.Preflight.WimMountRecovery.Tests.ps1:
```powershell
BeforeAll {
    $ModulePath = Join-Path $PSScriptRoot '../../FFUDevelopment/Modules'
    $env:PSModulePath = "$ModulePath;$env:PSModulePath"
    Import-Module FFU.Preflight -Force
}

Describe 'Test-WimMountDriverIntegrity' {
    Context 'When driver exists and is valid' {
        It 'Returns IsCorrupted = $false' {
            Mock Test-Path { $true } -ModuleName FFU.Preflight
            Mock Get-Item {
                [PSCustomObject]@{ Length = 25000 }
            } -ModuleName FFU.Preflight
            Mock Get-FileHash {
                [PSCustomObject]@{ Hash = 'ABC123' }
            } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-WimMountDriverIntegrity
                $result.IsCorrupted | Should -Be $false
            }
        }
    }

    Context 'When driver is suspiciously small' {
        It 'Returns IsCorrupted = $true with reason' {
            Mock Test-Path { $true } -ModuleName FFU.Preflight
            Mock Get-Item {
                [PSCustomObject]@{ Length = 500 }  # Too small
            } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-WimMountDriverIntegrity
                $result.IsCorrupted | Should -Be $true
                $result.Reason | Should -Match 'suspiciously small'
            }
        }
    }

    Context 'When driver file missing' {
        It 'Returns IsCorrupted = $true' {
            Mock Test-Path { $false } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-WimMountDriverIntegrity
                $result.IsCorrupted | Should -Be $true
                $result.Reason | Should -Match 'missing'
            }
        }
    }
}

Describe 'Test-WimMountAltitudeConflict' {
    Context 'When no conflict exists' {
        It 'Returns HasConflict = $false' {
            Mock fltmc {
                @(
                    'Filter Name                     Num Instances    Altitude    Frame',
                    '-----------                     -------------    --------    -----',
                    'WimMount                        2                180700      0'
                )
            } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-WimMountAltitudeConflict
                $result.HasConflict | Should -Be $false
                $result.WimMountLoaded | Should -Be $true
            }
        }
    }

    Context 'When another filter uses altitude 180700' {
        It 'Returns HasConflict = $true with conflicting filter' {
            Mock fltmc {
                @(
                    'Filter Name                     Num Instances    Altitude    Frame',
                    '-----------                     -------------    --------    -----',
                    'SomeOtherFilter                 1                180700      0'
                )
            } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-WimMountAltitudeConflict
                $result.HasConflict | Should -Be $true
                $result.ConflictingFilters | Should -HaveCount 1
                $result.ConflictingFilters[0].Name | Should -Be 'SomeOtherFilter'
            }
        }
    }
}

Describe 'Test-WimMountSecuritySoftwareBlocking' {
    Context 'When no security software detected' {
        It 'Returns BlockingLikely = $false' {
            Mock Get-Service { $null } -ModuleName FFU.Preflight
            Mock fltmc {
                @(
                    'Filter Name                     Num Instances    Altitude    Frame',
                    '-----------                     -------------    --------    -----',
                    'WimMount                        2                180700      0'
                )
            } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-WimMountSecuritySoftwareBlocking
                $result.BlockingLikely | Should -Be $false
                $result.DetectedSoftware | Should -HaveCount 0
            }
        }
    }

    Context 'When CrowdStrike detected' {
        It 'Returns BlockingLikely = $true with CrowdStrike details' {
            Mock Get-Service {
                if ($Name -eq 'CSFalconService') {
                    [PSCustomObject]@{ Status = 'Running' }
                }
            } -ModuleName FFU.Preflight

            Mock fltmc {
                @(
                    'Filter Name                     Num Instances    Altitude    Frame',
                    '-----------                     -------------    --------    -----',
                    'CSAgent                         5                385201      0'
                )
            } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-WimMountSecuritySoftwareBlocking
                $result.BlockingLikely | Should -Be $true
                $result.DetectedSoftware.Count | Should -BeGreaterThan 0
            }
        }
    }
}

Describe 'Test-FFUWimMount Enhanced Detection' {
    Context 'When WimMount is healthy' {
        It 'Returns Passed status' {
            Mock fltmc {
                @(
                    'Filter Name                     Num Instances    Altitude    Frame',
                    '-----------                     -------------    --------    -----',
                    'WimMount                        2                180700      0'
                )
            } -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-FFUWimMount
                $result.Status | Should -Be 'Passed'
            }
        }
    }

    Context 'When WimMount not loaded' {
        It 'Returns Failed status with diagnostic details' {
            Mock fltmc { @() } -ModuleName FFU.Preflight
            Mock Test-Path { $true } -ModuleName FFU.Preflight
            Mock Get-Item { [PSCustomObject]@{ Length = 25000 } } -ModuleName FFU.Preflight
            Mock Get-FileHash { [PSCustomObject]@{ Hash = 'ABC' } } -ModuleName FFU.Preflight
            Mock Get-Service { $null } -ModuleName FFU.Preflight
            Mock sc.exe { 'SERVICE_NAME: wimmount' } -ModuleName FFU.Preflight
            Mock Set-ItemProperty {} -ModuleName FFU.Preflight
            Mock New-Item {} -ModuleName FFU.Preflight

            InModuleScope FFU.Preflight {
                $result = Test-FFUWimMount -AttemptRemediation:$false
                $result.Status | Should -Be 'Failed'
                $result.Details.WimMountFilterLoaded | Should -Be $false
            }
        }
    }
}

AfterAll {
    # Cleanup
}
```
  </action>
  <verify>
Run: `Invoke-Pester -Path Tests/Unit/FFU.Preflight.WimMountRecovery.Tests.ps1 -Output Detailed`
All tests should pass.
  </verify>
  <done>
- Test-WimMountSecuritySoftwareBlocking helper added
- Common EDR/security software detected (CrowdStrike, SentinelOne, etc.)
- Security blocking adds specific remediation
- FFU.Preflight version bumped to 1.0.14
- version.json updated
- 15+ Pester tests created and passing
  </done>
</task>

</tasks>

<verification>
1. `Import-Module FFU.Preflight -Force` succeeds
2. `(Get-Module FFU.Preflight).Version` returns 1.0.14
3. `Test-FFUWimMount` returns detailed diagnostics including driver integrity, altitude, security
4. All Pester tests pass
</verification>

<success_criteria>
- Driver integrity checked via hash and size
- Filter altitude conflicts detected via fltmc parsing
- Common EDR/security software detected
- Each failure type has specific remediation guidance
- FFU.Preflight module version = 1.0.14
- version.json updated
- 15+ Pester tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-dependency-resilience/10-03-SUMMARY.md`
</output>
