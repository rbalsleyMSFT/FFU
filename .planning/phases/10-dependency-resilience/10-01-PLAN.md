---
phase: 10-dependency-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1
  - FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1
  - Tests/Unit/FFU.Hypervisor.VMwareFallback.Tests.ps1
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GetVM returns VM info when vmxtoolkit unavailable but VM is running"
    - "GetAllVMs returns running VMs via vmrun list when vmxtoolkit unavailable"
    - "GetAllVMs searches common VM directories when vmxtoolkit unavailable"
    - "Pre-flight warns (not fails) when vmxtoolkit missing for VMware builds"
  artifacts:
    - path: "FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1"
      provides: "Enhanced VM discovery fallback methods"
      contains: "SearchVMXFilesystem"
    - path: "Tests/Unit/FFU.Hypervisor.VMwareFallback.Tests.ps1"
      provides: "Pester tests for fallback behavior"
      min_lines: 80
  key_links:
    - from: "VMwareProvider.GetVM"
      to: "vmrun list + filesystem scan"
      via: "fallback chain when vmxtoolkit fails"
      pattern: "SearchVMXFilesystem"
    - from: "Test-FFUVmxToolkit"
      to: "warning result"
      via: "Status property"
      pattern: "Warning.*optional"
---

<objective>
Enhance VMware provider VM discovery to work reliably without vmxtoolkit by implementing
filesystem-based VMX search as fallback, and update pre-flight to treat vmxtoolkit as optional.

Purpose: vmxtoolkit is a community PowerShell module that may not be available in all environments.
The VMware provider should function fully with just vmrun.exe (which ships with VMware Workstation).

Output:
- VMwareProvider.ps1 with SearchVMXFilesystem fallback method
- Updated Test-FFUVmxToolkit returning Warning instead of Failed when missing
- Pester tests verifying fallback behavior
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-dependency-resilience/10-RESEARCH.md
@FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1
@FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add VMX filesystem search fallback to VMwareProvider</name>
  <files>FFUDevelopment/Modules/FFU.Hypervisor/Providers/VMwareProvider.ps1</files>
  <action>
Add a hidden helper method SearchVMXFilesystem that searches common VM storage locations
for VMX files when vmxtoolkit is unavailable. This enables GetVM and GetAllVMs to find
VMs even without vmxtoolkit.

1. Add hidden method `SearchVMXFilesystem`:
```powershell
hidden [string[]] SearchVMXFilesystem([string]$VMName = $null) {
    # Search locations: default VMware folder, common paths, VMs found in preferences
    $searchPaths = @()

    # VMware default VM directory from preferences
    $prefsPath = Join-Path $env:APPDATA 'VMware\preferences.ini'
    if (Test-Path $prefsPath) {
        $prefs = Get-Content $prefsPath -ErrorAction SilentlyContinue
        $defaultVMPath = $prefs | Where-Object { $_ -match 'prefvmx\.defaultVMPath\s*=\s*"([^"]+)"' } |
            ForEach-Object { $Matches[1] }
        if ($defaultVMPath -and (Test-Path $defaultVMPath)) {
            $searchPaths += $defaultVMPath
        }
    }

    # Common default locations
    $commonPaths = @(
        (Join-Path $env:USERPROFILE 'Documents\Virtual Machines'),
        (Join-Path $env:USERPROFILE 'Virtual Machines'),
        'C:\VMs',
        'D:\VMs'
    )
    $searchPaths += $commonPaths | Where-Object { Test-Path $_ }

    # Search for VMX files
    $vmxFiles = @()
    foreach ($path in ($searchPaths | Select-Object -Unique)) {
        $found = Get-ChildItem -Path $path -Filter '*.vmx' -Recurse -Depth 2 -ErrorAction SilentlyContinue
        if ($VMName) {
            $found = $found | Where-Object { $_.BaseName -eq $VMName }
        }
        $vmxFiles += $found.FullName
    }

    return $vmxFiles
}
```

2. Update GetVM method to use filesystem search as final fallback:
After the vmrun list check (line ~536), add:
```powershell
# Fallback: Search filesystem for VMX files
$vmxPaths = $this.SearchVMXFilesystem($Name)
if ($vmxPaths) {
    $vmxPath = $vmxPaths | Select-Object -First 1
    $vmInfo = [VMInfo]::new()
    $vmInfo.Name = $Name
    $vmInfo.Id = $Name
    $vmInfo.HypervisorType = 'VMware'
    $vmInfo.VMwareId = $Name
    $vmInfo.VMXPath = $vmxPath
    $vmInfo.ConfigurationPath = $vmxPath

    # Check power state
    $powerState = Get-VMwarePowerStateWithVmrun -VMXPath $vmxPath
    $vmInfo.State = [VMInfo]::ConvertVMwareState($powerState)

    WriteLog "Found VM '$Name' via filesystem search: $vmxPath"
    return $vmInfo
}
```

3. Update GetAllVMs to combine vmrun list with filesystem search:
After the vmrun list processing (line ~602), add filesystem search to find stopped VMs:
```powershell
# Add VMs found via filesystem that aren't already in results (from vmrun list)
$vmxPaths = $this.SearchVMXFilesystem()
foreach ($vmxPath in $vmxPaths) {
    $vmName = [System.IO.Path]::GetFileNameWithoutExtension($vmxPath)

    # Skip if already found via vmrun list
    if ($results | Where-Object { $_.VMXPath -eq $vmxPath }) {
        continue
    }

    $vmInfo = [VMInfo]::new()
    $vmInfo.Name = $vmName
    $vmInfo.Id = $vmName
    $vmInfo.HypervisorType = 'VMware'
    $vmInfo.VMwareId = $vmName
    $vmInfo.VMXPath = $vmxPath
    $vmInfo.ConfigurationPath = $vmxPath

    # Check power state (likely Off since not in vmrun list)
    $powerState = Get-VMwarePowerStateWithVmrun -VMXPath $vmxPath
    $vmInfo.State = [VMInfo]::ConvertVMwareState($powerState)

    $results += $vmInfo
}
```

4. Update module version in header comment: Version: 1.3.0
  </action>
  <verify>
Run: `Import-Module FFU.Hypervisor -Force; (Get-VMwareProvider).GetType().GetMethods() | Where-Object Name -eq 'SearchVMXFilesystem'`
Confirm method exists (will show non-public method).
  </verify>
  <done>
- SearchVMXFilesystem method added to VMwareProvider
- GetVM uses filesystem search when vmxtoolkit unavailable and vmrun list misses
- GetAllVMs combines vmrun list with filesystem search for complete VM list
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Test-FFUVmxToolkit to treat as optional (warning not failure)</name>
  <files>FFUDevelopment/Modules/FFU.Preflight/FFU.Preflight.psm1</files>
  <action>
Find Test-FFUVmxToolkit function and update it to return Warning status instead of Failed
when vmxtoolkit module is not installed. The module is optional - vmrun.exe handles all
VM operations directly, vmxtoolkit just provides convenience.

Search for `function Test-FFUVmxToolkit` (likely around line 1600-1700).

Change the failure result to warning:
- Status: 'Warning' instead of 'Failed'
- Message: Include "(optional - vmrun.exe fallback available)"
- Remediation: Explain vmxtoolkit is optional, provide install instructions for users who want it

Example updated result when vmxtoolkit is not found:
```powershell
return (New-FFUCheckResult -CheckName 'VmxToolkit' -Status 'Warning' `
    -Message 'vmxtoolkit module not installed (optional - vmrun.exe fallback available)' `
    -Details @{
        ModuleAvailable = $false
        ModuleVersion = 'Not installed'
        FallbackAvailable = $true
    } `
    -Remediation @"
The vmxtoolkit PowerShell module is not installed. This is OPTIONAL.

VMware VM operations will use vmrun.exe directly, which is fully functional
for all FFU Builder operations including:
- Creating VMs
- Starting/stopping VMs
- Attaching ISO files
- Querying VM state

To install vmxtoolkit for enhanced VM discovery (finds stopped VMs):
  Install-Module -Name vmxtoolkit -Scope CurrentUser

The build will proceed without vmxtoolkit using vmrun.exe fallback.
"@ `
    -DurationMs $stopwatch.ElapsedMilliseconds)
```

Also update the Invoke-FFUPreflight function to NOT count vmxtoolkit warnings as blocking
failures when calculating the final result. Ensure vmxtoolkit failures only result in
a warning message, not a blocked build.

Update module version in FFU.Preflight.psd1: ModuleVersion = '1.0.13'
Add release notes documenting vmxtoolkit is now optional.
  </action>
  <verify>
Run: `Import-Module FFU.Preflight -Force; $result = Test-FFUVmxToolkit; $result.Status`
Expected: Returns 'Passed' if vmxtoolkit installed, 'Warning' if not installed.
  </verify>
  <done>
- Test-FFUVmxToolkit returns Warning (not Failed) when module missing
- Invoke-FFUPreflight treats vmxtoolkit warnings as non-blocking
- FFU.Preflight module version bumped to 1.0.13
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Pester tests for VMware fallback behavior</name>
  <files>Tests/Unit/FFU.Hypervisor.VMwareFallback.Tests.ps1</files>
  <action>
Create comprehensive Pester tests verifying the vmxtoolkit fallback behavior.

Tests to include:

1. **SearchVMXFilesystem tests** (InModuleScope required for hidden method)
   - Returns empty array when no VMs in search paths
   - Finds VMX files in Documents\Virtual Machines
   - Filters by VM name when parameter provided
   - Handles missing directories gracefully

2. **GetVM fallback tests**
   - Returns VM info from vmrun list when running
   - Returns VM info from filesystem search when vmxtoolkit unavailable
   - Returns null when VM not found anywhere

3. **GetAllVMs fallback tests**
   - Returns running VMs from vmrun list when vmxtoolkit unavailable
   - Combines vmrun list with filesystem search results
   - Deduplicates VMs found in both sources

4. **Test-FFUVmxToolkit warning behavior**
   - Returns Passed when vmxtoolkit installed
   - Returns Warning (not Failed) when vmxtoolkit not installed
   - Warning message indicates vmrun.exe fallback available

Use mocks extensively:
- Mock Get-Module to simulate vmxtoolkit presence/absence
- Mock Get-ChildItem for filesystem search
- Mock Get-Content for preferences file
- Mock Get-VMwarePowerStateWithVmrun for state checks

Structure:
```powershell
BeforeAll {
    $ModulePath = Join-Path $PSScriptRoot '../../FFUDevelopment/Modules'
    $env:PSModulePath = "$ModulePath;$env:PSModulePath"

    # Mock WriteLog
    function global:WriteLog { param($Message) }

    Import-Module FFU.Hypervisor -Force
}

Describe 'VMware Provider Fallback Behavior' {
    Context 'SearchVMXFilesystem (Hidden Method)' {
        # Tests using InModuleScope
    }

    Context 'GetVM Fallback Chain' {
        # Tests for GetVM without vmxtoolkit
    }

    Context 'GetAllVMs Fallback Chain' {
        # Tests for GetAllVMs without vmxtoolkit
    }
}

Describe 'Test-FFUVmxToolkit Warning Behavior' {
    Context 'When vmxtoolkit installed' {
        # Should return Passed
    }

    Context 'When vmxtoolkit not installed' {
        # Should return Warning, not Failed
    }
}

AfterAll {
    Remove-Item Function:\WriteLog -ErrorAction SilentlyContinue
}
```
  </action>
  <verify>
Run: `Invoke-Pester -Path Tests/Unit/FFU.Hypervisor.VMwareFallback.Tests.ps1 -Output Detailed`
All tests should pass.
  </verify>
  <done>
- Pester test file created with 15+ tests covering fallback scenarios
- Tests verify filesystem search, GetVM/GetAllVMs fallback chains
- Tests verify vmxtoolkit warning behavior (not failure)
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. Import VMwareProvider and verify SearchVMXFilesystem method exists
2. Test-FFUVmxToolkit returns Warning when vmxtoolkit not installed
3. All Pester tests in FFU.Hypervisor.VMwareFallback.Tests.ps1 pass
4. VMware builds work without vmxtoolkit installed (vmrun.exe used)
</verification>

<success_criteria>
- VMwareProvider.GetVM finds VMs via filesystem when vmxtoolkit unavailable
- VMwareProvider.GetAllVMs lists both running and stopped VMs without vmxtoolkit
- Test-FFUVmxToolkit returns Warning (not Failed) when vmxtoolkit missing
- Pre-flight validation passes with only vmrun.exe available
- 15+ Pester tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-dependency-resilience/10-01-SUMMARY.md`
</output>
