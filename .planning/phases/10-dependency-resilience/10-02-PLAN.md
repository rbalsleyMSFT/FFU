---
phase: 10-dependency-resilience
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - FFUDevelopment/FFUUI.Core/FFUUI.Core.Drivers.Lenovo.psm1
  - FFUDevelopment/FFUUI.Core/FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1
  - Tests/Unit/FFU.Drivers.Lenovo.CatalogFallback.Tests.ps1
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Lenovo driver discovery falls back to catalogv2.xml when PSREF API fails"
    - "catalogv2.xml fallback returns enterprise ThinkPad/ThinkCentre models"
    - "User is informed when operating in fallback mode (partial coverage)"
    - "catalogv2.xml is cached locally with configurable TTL"
  artifacts:
    - path: "FFUDevelopment/FFUUI.Core/FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1"
      provides: "catalogv2.xml parser and fallback functions"
      exports: ["Get-LenovoCatalogV2Models", "Get-LenovoCatalogV2DriverUrl"]
      min_lines: 150
    - path: "FFUDevelopment/FFUUI.Core/FFUUI.Core.Drivers.Lenovo.psm1"
      provides: "Updated Get-LenovoDriversModelList with fallback"
      contains: "Get-LenovoCatalogV2Models"
    - path: "Tests/Unit/FFU.Drivers.Lenovo.CatalogFallback.Tests.ps1"
      provides: "Pester tests for catalog fallback"
      min_lines: 100
  key_links:
    - from: "Get-LenovoDriversModelList"
      to: "Get-LenovoCatalogV2Models"
      via: "try/catch fallback on PSREF failure"
      pattern: "catch.*Get-LenovoCatalogV2Models"
    - from: "Get-LenovoCatalogV2Models"
      to: "catalogv2.xml"
      via: "XML parsing"
      pattern: "download\\.lenovo\\.com/cdrt/td/catalogv2\\.xml"
---

<objective>
Implement Lenovo catalogv2.xml fallback for driver discovery when PSREF API authentication fails.

Purpose: The PSREF API requires a JWT token obtained via browser automation which can fail.
The catalogv2.xml provides enterprise model coverage as a reliable fallback source.

Output:
- New module FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1 for catalog parsing
- Updated Get-LenovoDriversModelList with automatic fallback
- Pester tests verifying fallback behavior
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-dependency-resilience/10-RESEARCH.md
@FFUDevelopment/FFUUI.Core/FFUUI.Core.Drivers.Lenovo.psm1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FFUUI.Core.Drivers.Lenovo.CatalogFallback module</name>
  <files>FFUDevelopment/FFUUI.Core/FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1</files>
  <action>
Create a new module that parses the Lenovo catalogv2.xml file to provide model discovery
and driver URL lookup as fallback when PSREF API is unavailable.

catalogv2.xml structure (from research):
```xml
<Products>
  <Product>
    <Model name="ThinkPad L490">
      <Types>
        <Type mtm="20Q6" name="20Q6">
          <SCCM os="win10" version="22H2" date="2024-03-15" md5="...">
            https://download.lenovo.com/pccbbs/mobiles/tp_l490_w10_22h2_sccm.exe
          </SCCM>
        </Type>
      </Types>
    </Model>
  </Product>
</Products>
```

Module contents:

```powershell
<#
.SYNOPSIS
    Lenovo catalogv2.xml fallback for driver discovery when PSREF API unavailable.

.DESCRIPTION
    Provides enterprise model coverage (ThinkPad, ThinkCentre, ThinkStation) from
    the Lenovo catalogv2.xml catalog when PSREF API authentication fails.

    IMPORTANT: catalogv2.xml has PARTIAL coverage compared to PSREF:
    - Included: ThinkPad, ThinkCentre, ThinkStation enterprise models
    - Missing: 300w, 500w, 100e, and other consumer/education models

.NOTES
    Module: FFUUI.Core.Drivers.Lenovo.CatalogFallback
    Version: 1.0.0
#>

# Module-scoped cache
$script:CatalogCache = @{
    Data = $null
    CachedAt = [DateTime]::MinValue
    TTLMinutes = 10080  # 7 days default
}

function Get-LenovoCatalogV2 {
    <#
    .SYNOPSIS
        Downloads and caches the Lenovo catalogv2.xml file.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$FFUDevelopmentPath = $null,

        [Parameter()]
        [switch]$ForceRefresh
    )

    $catalogUrl = 'https://download.lenovo.com/cdrt/td/catalogv2.xml'

    # Use local cache file if available
    if ([string]::IsNullOrEmpty($FFUDevelopmentPath)) {
        $FFUDevelopmentPath = Split-Path -Path (Split-Path -Path $PSScriptRoot -Parent) -Parent
    }
    $cacheDir = Join-Path $FFUDevelopmentPath '.cache'
    $cachePath = Join-Path $cacheDir 'catalogv2.xml'

    # Check memory cache first
    $cacheAge = ([DateTime]::Now - $script:CatalogCache.CachedAt).TotalMinutes
    if (-not $ForceRefresh -and $script:CatalogCache.Data -and $cacheAge -lt $script:CatalogCache.TTLMinutes) {
        return $script:CatalogCache.Data
    }

    # Check file cache
    if (-not $ForceRefresh -and (Test-Path $cachePath)) {
        $fileAge = ([DateTime]::Now - (Get-Item $cachePath).LastWriteTime).TotalMinutes
        if ($fileAge -lt $script:CatalogCache.TTLMinutes) {
            try {
                [xml]$catalog = Get-Content -Path $cachePath -Encoding UTF8 -ErrorAction Stop
                $script:CatalogCache.Data = $catalog
                $script:CatalogCache.CachedAt = (Get-Item $cachePath).LastWriteTime
                WriteLog "Loaded catalogv2.xml from file cache (age: $([int]$fileAge) minutes)"
                return $catalog
            }
            catch {
                WriteLog "Failed to load cached catalog: $($_.Exception.Message)"
            }
        }
    }

    # Download fresh catalog
    WriteLog "Downloading Lenovo catalogv2.xml from $catalogUrl..."
    try {
        # Ensure cache directory exists
        if (-not (Test-Path $cacheDir)) {
            New-Item -Path $cacheDir -ItemType Directory -Force | Out-Null
        }

        # Download to temp then move
        $tempPath = Join-Path $env:TEMP "catalogv2_$(Get-Random).xml"
        Invoke-WebRequest -Uri $catalogUrl -OutFile $tempPath -UseBasicParsing -ErrorAction Stop

        # Parse to validate
        [xml]$catalog = Get-Content -Path $tempPath -Encoding UTF8 -ErrorAction Stop

        # Move to cache
        Move-Item -Path $tempPath -Destination $cachePath -Force

        # Update memory cache
        $script:CatalogCache.Data = $catalog
        $script:CatalogCache.CachedAt = [DateTime]::Now

        WriteLog "Downloaded and cached catalogv2.xml successfully"
        return $catalog
    }
    catch {
        WriteLog "ERROR: Failed to download catalogv2.xml: $($_.Exception.Message)"
        throw
    }
}

function Get-LenovoCatalogV2Models {
    <#
    .SYNOPSIS
        Searches catalogv2.xml for models matching the search term.

    .DESCRIPTION
        Returns model information from catalogv2.xml as fallback when PSREF unavailable.
        NOTE: Only enterprise models (ThinkPad, ThinkCentre, ThinkStation) are included.

    .PARAMETER ModelSearchTerm
        The model name or machine type to search for.

    .OUTPUTS
        Array of PSCustomObjects with Make, Model, ProductName, MachineType properties.
    #>
    [CmdletBinding()]
    [OutputType([PSCustomObject[]])]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ModelSearchTerm,

        [Parameter()]
        [string]$FFUDevelopmentPath = $null
    )

    $models = [System.Collections.Generic.List[PSCustomObject]]::new()

    try {
        $catalog = Get-LenovoCatalogV2 -FFUDevelopmentPath $FFUDevelopmentPath

        # Log that we're in fallback mode
        WriteLog "FALLBACK MODE: Searching catalogv2.xml (partial coverage - enterprise models only)"

        # Search products
        foreach ($product in $catalog.Products.Product) {
            foreach ($model in $product.Model) {
                $modelName = $model.name

                # Check if model name matches search term
                if ($modelName -like "*$ModelSearchTerm*") {
                    foreach ($type in $model.Types.Type) {
                        $machineType = $type.mtm

                        if (-not [string]::IsNullOrWhiteSpace($machineType)) {
                            $displayModel = "$modelName ($machineType)"
                            $models.Add([PSCustomObject]@{
                                Make        = 'Lenovo'
                                Model       = $displayModel
                                ProductName = $modelName
                                MachineType = $machineType
                                IsFallback  = $true  # Flag to indicate fallback source
                            })
                        }
                    }
                }
            }
        }

        # Also search by machine type
        if ($models.Count -eq 0) {
            foreach ($product in $catalog.Products.Product) {
                foreach ($model in $product.Model) {
                    foreach ($type in $model.Types.Type) {
                        if ($type.mtm -like "*$ModelSearchTerm*") {
                            $modelName = $model.name
                            $machineType = $type.mtm
                            $displayModel = "$modelName ($machineType)"

                            $models.Add([PSCustomObject]@{
                                Make        = 'Lenovo'
                                Model       = $displayModel
                                ProductName = $modelName
                                MachineType = $machineType
                                IsFallback  = $true
                            })
                        }
                    }
                }
            }
        }

        if ($models.Count -gt 0) {
            WriteLog "Found $($models.Count) models in catalogv2.xml for '$ModelSearchTerm' (fallback mode)"
        }
        else {
            WriteLog "No models found in catalogv2.xml for '$ModelSearchTerm'. This model may require PSREF API."
        }
    }
    catch {
        WriteLog "ERROR: Failed to search catalogv2.xml: $($_.Exception.Message)"
    }

    return $models.ToArray()
}

function Get-LenovoCatalogV2DriverUrl {
    <#
    .SYNOPSIS
        Gets the SCCM driver pack URL for a specific machine type from catalogv2.xml.

    .PARAMETER MachineType
        The Lenovo machine type (e.g., "20Q6").

    .PARAMETER WindowsVersion
        The Windows version (e.g., "22H2", "23H2").

    .OUTPUTS
        String URL to the SCCM driver pack, or $null if not found.
    #>
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory = $true)]
        [string]$MachineType,

        [Parameter()]
        [string]$WindowsVersion = '22H2',

        [Parameter()]
        [string]$FFUDevelopmentPath = $null
    )

    try {
        $catalog = Get-LenovoCatalogV2 -FFUDevelopmentPath $FFUDevelopmentPath

        foreach ($product in $catalog.Products.Product) {
            foreach ($model in $product.Model) {
                foreach ($type in $model.Types.Type) {
                    if ($type.mtm -eq $MachineType) {
                        # Look for SCCM pack matching Windows version
                        foreach ($sccm in $type.SCCM) {
                            if ($sccm.version -eq $WindowsVersion -and $sccm.os -eq 'win10') {
                                $url = $sccm.InnerText.Trim()
                                if (-not [string]::IsNullOrWhiteSpace($url)) {
                                    WriteLog "Found SCCM pack for $MachineType Win$WindowsVersion: $url"
                                    return $url
                                }
                            }
                        }
                        # Fallback: any SCCM pack for win10
                        foreach ($sccm in $type.SCCM) {
                            if ($sccm.os -eq 'win10') {
                                $url = $sccm.InnerText.Trim()
                                if (-not [string]::IsNullOrWhiteSpace($url)) {
                                    WriteLog "Found alternate SCCM pack for $MachineType: $url (version: $($sccm.version))"
                                    return $url
                                }
                            }
                        }
                    }
                }
            }
        }

        WriteLog "No SCCM driver pack found in catalogv2.xml for machine type: $MachineType"
        return $null
    }
    catch {
        WriteLog "ERROR: Failed to lookup driver URL: $($_.Exception.Message)"
        return $null
    }
}

Export-ModuleMember -Function Get-LenovoCatalogV2, Get-LenovoCatalogV2Models, Get-LenovoCatalogV2DriverUrl
```
  </action>
  <verify>
Run: `Import-Module .\FFUDevelopment\FFUUI.Core\FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1 -Force; Get-Command -Module FFUUI.Core.Drivers.Lenovo.CatalogFallback`
Expected: Lists Get-LenovoCatalogV2, Get-LenovoCatalogV2Models, Get-LenovoCatalogV2DriverUrl
  </verify>
  <done>
- FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1 created
- Get-LenovoCatalogV2 downloads and caches XML with 7-day TTL
- Get-LenovoCatalogV2Models searches for models by name or machine type
- Get-LenovoCatalogV2DriverUrl returns SCCM pack URL for machine type
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate catalogv2.xml fallback into Get-LenovoDriversModelList</name>
  <files>FFUDevelopment/FFUUI.Core/FFUUI.Core.Drivers.Lenovo.psm1</files>
  <action>
Update Get-LenovoDriversModelList to automatically fall back to catalogv2.xml when
PSREF API fails (401/403 errors or token retrieval failure).

1. Add import at top of module (after existing module comments):
```powershell
# Import catalog fallback module for PSREF API fallback
$catalogFallbackPath = Join-Path $PSScriptRoot 'FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1'
if (Test-Path $catalogFallbackPath) {
    Import-Module $catalogFallbackPath -Force -ErrorAction SilentlyContinue
}
```

2. Update Get-LenovoDriversModelList function.

In the catch block (around line 91-93), instead of just logging and returning empty:
```powershell
catch {
    WriteLog "Error querying Lenovo PSREF API: $($_.Exception.Message)"

    # Attempt fallback to catalogv2.xml
    WriteLog "Attempting fallback to catalogv2.xml catalog..."
    try {
        $fallbackModels = Get-LenovoCatalogV2Models -ModelSearchTerm $ModelSearchTerm
        if ($fallbackModels -and $fallbackModels.Count -gt 0) {
            WriteLog "PSREF API failed, using catalogv2.xml fallback ($($fallbackModels.Count) models found)"
            WriteLog "NOTE: Fallback mode has partial coverage - consumer models (300w, 500w, 100e) not available"
            foreach ($model in $fallbackModels) {
                $models.Add($model)
            }
        }
        else {
            WriteLog "No models found in PSREF API or catalogv2.xml fallback for '$ModelSearchTerm'"
        }
    }
    catch {
        WriteLog "Fallback to catalogv2.xml also failed: $($_.Exception.Message)"
    }
}
```

3. Also add a fallback check after the main PSREF query when no models are found
(around line 86-88). If PSREF returns empty but no error, user might have searched
for a model that's only in catalogv2.xml:
```powershell
if ($models.Count -eq 0) {
    WriteLog "No models found in PSREF, checking catalogv2.xml fallback..."
    try {
        $fallbackModels = Get-LenovoCatalogV2Models -ModelSearchTerm $ModelSearchTerm
        if ($fallbackModels -and $fallbackModels.Count -gt 0) {
            WriteLog "Found $($fallbackModels.Count) models in catalogv2.xml"
            foreach ($model in $fallbackModels) {
                $models.Add($model)
            }
        }
    }
    catch {
        WriteLog "catalogv2.xml lookup failed: $($_.Exception.Message)"
    }
}
```

4. Update module header comment to document fallback behavior.
  </action>
  <verify>
Manual test (requires network):
1. Mock PSREF token to fail
2. Call Get-LenovoDriversModelList with "ThinkPad"
3. Verify it falls back to catalogv2.xml and returns results

Or: Search for 'catalogv2' in the module to confirm integration.
  </verify>
  <done>
- FFUUI.Core.Drivers.Lenovo.psm1 imports catalog fallback module
- Get-LenovoDriversModelList falls back on PSREF API errors
- Get-LenovoDriversModelList checks catalogv2.xml when PSREF returns empty
- User informed when operating in fallback mode
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Pester tests for Lenovo catalog fallback</name>
  <files>Tests/Unit/FFU.Drivers.Lenovo.CatalogFallback.Tests.ps1</files>
  <action>
Create comprehensive Pester tests for the catalogv2.xml fallback functionality.

Tests to include:

1. **Get-LenovoCatalogV2 caching tests**
   - Downloads catalog on first call
   - Returns cached data on subsequent calls
   - Refreshes when ForceRefresh specified
   - Uses file cache when memory cache expired

2. **Get-LenovoCatalogV2Models tests**
   - Returns models matching search term
   - Searches by model name
   - Searches by machine type
   - Returns empty array when no matches
   - All results have IsFallback = $true

3. **Get-LenovoCatalogV2DriverUrl tests**
   - Returns URL for known machine type
   - Returns null for unknown machine type
   - Finds matching Windows version
   - Falls back to any available version

4. **Integration tests for fallback chain**
   - PSREF failure triggers catalogv2.xml fallback
   - Empty PSREF results trigger fallback
   - Fallback results marked appropriately

Mock the catalog XML to avoid network dependency in tests:
```powershell
$mockCatalogXml = @"
<?xml version="1.0"?>
<Products>
  <Product>
    <Model name="ThinkPad L490">
      <Types>
        <Type mtm="20Q6" name="20Q6">
          <SCCM os="win10" version="22H2" date="2024-03-15" md5="abc123">
            https://download.lenovo.com/test/tp_l490_drivers.exe
          </SCCM>
        </Type>
      </Types>
    </Model>
    <Model name="ThinkPad T14">
      <Types>
        <Type mtm="21HD" name="21HD">
          <SCCM os="win10" version="23H2" date="2024-06-01" md5="def456">
            https://download.lenovo.com/test/tp_t14_drivers.exe
          </SCCM>
        </Type>
      </Types>
    </Model>
  </Product>
</Products>
"@
```

Structure:
```powershell
BeforeAll {
    # Mock WriteLog
    function global:WriteLog { param($Message) }

    $ModulePath = Join-Path $PSScriptRoot '../../FFUDevelopment/FFUUI.Core'
    Import-Module (Join-Path $ModulePath 'FFUUI.Core.Drivers.Lenovo.CatalogFallback.psm1') -Force
}

Describe 'Get-LenovoCatalogV2' {
    # Caching tests
}

Describe 'Get-LenovoCatalogV2Models' {
    # Model search tests
}

Describe 'Get-LenovoCatalogV2DriverUrl' {
    # Driver URL lookup tests
}

Describe 'Lenovo Driver Fallback Chain' {
    # Integration tests
}

AfterAll {
    Remove-Item Function:\WriteLog -ErrorAction SilentlyContinue
}
```
  </action>
  <verify>
Run: `Invoke-Pester -Path Tests/Unit/FFU.Drivers.Lenovo.CatalogFallback.Tests.ps1 -Output Detailed`
All tests should pass.
  </verify>
  <done>
- Pester test file created with 20+ tests
- Tests cover catalog download/caching
- Tests cover model search functionality
- Tests cover driver URL lookup
- Tests cover fallback chain integration
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `Import-Module FFUUI.Core.Drivers.Lenovo.CatalogFallback` succeeds
2. `Get-LenovoCatalogV2Models -ModelSearchTerm "ThinkPad"` returns results
3. Lenovo model search falls back when PSREF unavailable
4. All Pester tests pass
</verification>

<success_criteria>
- catalogv2.xml downloaded and cached with 7-day TTL
- Model search returns ThinkPad/ThinkCentre/ThinkStation models from catalog
- PSREF API failure triggers automatic fallback
- User sees "fallback mode" message indicating partial coverage
- 20+ Pester tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-dependency-resilience/10-02-SUMMARY.md`
</output>
