---
phase: 03-security-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - FFUDevelopment/Modules/FFU.Core/FFU.Core.psm1
  - FFUDevelopment/Modules/FFU.Core/FFU.Core.psd1
  - FFUDevelopment/Apps/Orchestration/Orchestrator.ps1
  - FFUDevelopment/.security/orchestration-hashes.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Orchestration scripts are verified against hash manifest before execution"
    - "Hash mismatches log error and prevent script execution"
    - "Hash manifest uses SHA-256 algorithm"
    - "Verification can be enabled/disabled via configuration"
  artifacts:
    - path: "FFUDevelopment/Modules/FFU.Core/FFU.Core.psm1"
      provides: "Script integrity verification functions"
      exports: ["Test-ScriptIntegrity", "New-OrchestrationHashManifest", "Update-OrchestrationHashManifest"]
    - path: "FFUDevelopment/.security/orchestration-hashes.json"
      provides: "Hash manifest for orchestration scripts"
      contains: "SHA256 hashes for all orchestration scripts"
  key_links:
    - from: "Orchestrator.ps1"
      to: "FFU.Core.psm1:Test-ScriptIntegrity"
      via: "Pre-execution verification call"
      pattern: "Test-ScriptIntegrity"
    - from: "Test-ScriptIntegrity"
      to: ".security/orchestration-hashes.json"
      via: "Manifest lookup"
      pattern: "orchestration-hashes.json"
---

<objective>
Implement integrity verification for Apps orchestration scripts before execution (SEC-03).

Purpose: Orchestration scripts run inside the VM during FFU build and have full system access. Verifying their integrity before execution detects tampering and prevents execution of modified scripts.

Output: SHA-256 hash verification system with manifest file and pre-execution checks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-hardening/03-RESEARCH.md

# Source files
@FFUDevelopment/Modules/FFU.Core/FFU.Core.psm1
@FFUDevelopment/Apps/Orchestration/Orchestrator.ps1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add script integrity verification functions to FFU.Core</name>
  <files>FFUDevelopment/Modules/FFU.Core/FFU.Core.psm1, FFUDevelopment/Modules/FFU.Core/FFU.Core.psd1</files>
  <action>
Add three new functions to FFU.Core.psm1:

**1. Test-ScriptIntegrity:**
```powershell
function Test-ScriptIntegrity {
    <#
    .SYNOPSIS
    Verifies script integrity against expected SHA-256 hash

    .DESCRIPTION
    Calculates SHA-256 hash of a script file and compares against expected hash
    from manifest or parameter. Returns $true if match, $false if mismatch.

    .PARAMETER ScriptPath
    Full path to the script file to verify

    .PARAMETER ExpectedHash
    Optional - direct hash to compare against (overrides manifest lookup)

    .PARAMETER ManifestPath
    Optional - path to JSON manifest file containing expected hashes

    .PARAMETER FailOnMismatch
    If $true (default), logs ERROR on mismatch. If $false, logs WARNING.

    .EXAMPLE
    Test-ScriptIntegrity -ScriptPath "C:\Apps\Orchestrator.ps1" -ManifestPath "C:\FFU\.security\orchestration-hashes.json"
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateScript({ Test-Path $_ -PathType Leaf })]
        [string]$ScriptPath,

        [Parameter(Mandatory = $false)]
        [string]$ExpectedHash,

        [Parameter(Mandatory = $false)]
        [string]$ManifestPath,

        [Parameter(Mandatory = $false)]
        [bool]$FailOnMismatch = $true
    )

    # Calculate actual hash
    $actualHash = (Get-FileHash -Path $ScriptPath -Algorithm SHA256).Hash

    # Get expected hash from manifest if not provided directly
    if ([string]::IsNullOrEmpty($ExpectedHash) -and -not [string]::IsNullOrEmpty($ManifestPath)) {
        if (Test-Path $ManifestPath) {
            try {
                $manifest = Get-Content $ManifestPath -Raw | ConvertFrom-Json
                $scriptName = [System.IO.Path]::GetFileName($ScriptPath)
                $ExpectedHash = $manifest.scripts.$scriptName
            }
            catch {
                WriteLog "WARNING: Failed to read hash manifest: $($_.Exception.Message)"
            }
        }
        else {
            WriteLog "WARNING: Hash manifest not found at $ManifestPath"
        }
    }

    # If no expected hash available, log and return based on strict mode
    if ([string]::IsNullOrEmpty($ExpectedHash)) {
        WriteLog "WARNING: No expected hash for $(Split-Path $ScriptPath -Leaf) - skipping verification"
        return $true  # Permissive mode - allow execution when no hash available
    }

    # Compare hashes
    if ($actualHash -eq $ExpectedHash) {
        WriteLog "SECURITY: Verified integrity of $(Split-Path $ScriptPath -Leaf)"
        return $true
    }
    else {
        $logLevel = if ($FailOnMismatch) { "ERROR" } else { "WARNING" }
        WriteLog "$logLevel`: Hash mismatch for $(Split-Path $ScriptPath -Leaf)"
        WriteLog "  Expected: $ExpectedHash"
        WriteLog "  Actual:   $actualHash"
        return $false
    }
}
```

**2. New-OrchestrationHashManifest:**
```powershell
function New-OrchestrationHashManifest {
    <#
    .SYNOPSIS
    Generates hash manifest for all orchestration scripts

    .DESCRIPTION
    Calculates SHA-256 hashes for all .ps1 files in the orchestration folder
    and writes them to a JSON manifest file.

    .PARAMETER OrchestrationPath
    Path to the Apps/Orchestration folder

    .PARAMETER ManifestPath
    Output path for the manifest JSON file

    .EXAMPLE
    New-OrchestrationHashManifest -OrchestrationPath "C:\FFU\Apps\Orchestration" -ManifestPath "C:\FFU\.security\orchestration-hashes.json"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateScript({ Test-Path $_ -PathType Container })]
        [string]$OrchestrationPath,

        [Parameter(Mandatory = $true)]
        [string]$ManifestPath
    )

    $scripts = Get-ChildItem -Path $OrchestrationPath -Filter "*.ps1" -File
    $manifest = @{
        generated = (Get-Date).ToString('o')
        algorithm = 'SHA256'
        scripts = @{}
    }

    foreach ($script in $scripts) {
        $hash = (Get-FileHash -Path $script.FullName -Algorithm SHA256).Hash
        $manifest.scripts[$script.Name] = $hash
        WriteLog "Hashed $($script.Name): $hash"
    }

    # Ensure directory exists
    $manifestDir = Split-Path $ManifestPath -Parent
    if (-not (Test-Path $manifestDir)) {
        New-Item -Path $manifestDir -ItemType Directory -Force | Out-Null
    }

    $manifest | ConvertTo-Json -Depth 3 | Set-Content -Path $ManifestPath -Encoding UTF8
    WriteLog "Generated manifest at $ManifestPath with $($scripts.Count) scripts"

    return $manifest
}
```

**3. Update-OrchestrationHashManifest:**
```powershell
function Update-OrchestrationHashManifest {
    <#
    .SYNOPSIS
    Updates hash manifest for specific scripts (leaves others unchanged)

    .DESCRIPTION
    Recalculates hashes only for specified scripts, preserving existing hashes.

    .PARAMETER OrchestrationPath
    Path to the Apps/Orchestration folder

    .PARAMETER ManifestPath
    Path to the manifest JSON file

    .PARAMETER ScriptNames
    Array of script names to update (e.g., "Orchestrator.ps1")

    .EXAMPLE
    Update-OrchestrationHashManifest -OrchestrationPath "C:\FFU\Apps\Orchestration" -ManifestPath "C:\FFU\.security\orchestration-hashes.json" -ScriptNames @("Orchestrator.ps1")
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$OrchestrationPath,

        [Parameter(Mandatory = $true)]
        [string]$ManifestPath,

        [Parameter(Mandatory = $true)]
        [string[]]$ScriptNames
    )

    # Load existing manifest or create new
    if (Test-Path $ManifestPath) {
        $manifest = Get-Content $ManifestPath -Raw | ConvertFrom-Json -AsHashtable
    }
    else {
        $manifest = @{
            generated = (Get-Date).ToString('o')
            algorithm = 'SHA256'
            scripts = @{}
        }
    }

    foreach ($scriptName in $ScriptNames) {
        $scriptPath = Join-Path $OrchestrationPath $scriptName
        if (Test-Path $scriptPath) {
            $hash = (Get-FileHash -Path $scriptPath -Algorithm SHA256).Hash
            $manifest.scripts[$scriptName] = $hash
            WriteLog "Updated hash for $scriptName`: $hash"
        }
        else {
            WriteLog "WARNING: Script not found: $scriptPath"
        }
    }

    $manifest.generated = (Get-Date).ToString('o')
    $manifest | ConvertTo-Json -Depth 3 | Set-Content -Path $ManifestPath -Encoding UTF8
    WriteLog "Updated manifest at $ManifestPath"
}
```

**Export functions** in FFU.Core.psm1's Export-ModuleMember.

**Update FFU.Core.psd1** manifest:
- Add the three new functions to FunctionsToExport array
- Bump ModuleVersion (patch increment)
  </action>
  <verify>
Import-Module FFU.Core -Force should succeed.
Get-Command -Module FFU.Core | Where-Object { $_.Name -like '*ScriptIntegrity*' -or $_.Name -like '*OrchestrationHash*' } should return 3 functions.
  </verify>
  <done>
Three script integrity verification functions implemented and exported from FFU.Core.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate initial hash manifest for orchestration scripts</name>
  <files>FFUDevelopment/.security/orchestration-hashes.json</files>
  <action>
Create the initial hash manifest using the new function:

1. Create the `.security` directory in FFUDevelopment if it doesn't exist

2. Calculate SHA-256 hashes for all orchestration scripts:
   - Orchestrator.ps1
   - Install-StoreApps.ps1
   - Install-Win32Apps.ps1
   - Invoke-AppsScript.ps1
   - Run-DiskCleanup.ps1
   - Run-Sysprep.ps1

3. Generate manifest JSON file at `FFUDevelopment/.security/orchestration-hashes.json`:
```json
{
    "generated": "2026-01-19T12:00:00.0000000-05:00",
    "algorithm": "SHA256",
    "version": "1.0.0",
    "scripts": {
        "Orchestrator.ps1": "<ACTUAL_HASH>",
        "Install-StoreApps.ps1": "<ACTUAL_HASH>",
        "Install-Win32Apps.ps1": "<ACTUAL_HASH>",
        "Invoke-AppsScript.ps1": "<ACTUAL_HASH>",
        "Run-DiskCleanup.ps1": "<ACTUAL_HASH>",
        "Run-Sysprep.ps1": "<ACTUAL_HASH>"
    }
}
```

Use PowerShell to generate:
```powershell
# After importing FFU.Core with new functions
$ffuPath = "C:\claude\FFUBuilder\FFUDevelopment"
$orchestrationPath = Join-Path $ffuPath "Apps\Orchestration"
$manifestPath = Join-Path $ffuPath ".security\orchestration-hashes.json"

New-OrchestrationHashManifest -OrchestrationPath $orchestrationPath -ManifestPath $manifestPath
```
  </action>
  <verify>
Test-Path "FFUDevelopment/.security/orchestration-hashes.json" should return $true.
Get-Content "FFUDevelopment/.security/orchestration-hashes.json" | ConvertFrom-Json should have scripts property with 6 entries.
  </verify>
  <done>
Initial hash manifest generated for all 6 orchestration scripts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integrity verification to Orchestrator.ps1</name>
  <files>FFUDevelopment/Apps/Orchestration/Orchestrator.ps1</files>
  <action>
Modify Orchestrator.ps1 to verify script integrity before execution:

**Add near the top (after the header Write-Host statements):**
```powershell
# Script Integrity Verification
# Verifies scripts against hash manifest before execution (SEC-03)
$verifyIntegrity = $true  # Set to $false to disable verification

if ($verifyIntegrity) {
    # Derive paths
    $ffuDevelopmentPath = Split-Path -Path (Split-Path -Path $scriptPath -Parent) -Parent
    $manifestPath = Join-Path $ffuDevelopmentPath ".security\orchestration-hashes.json"

    # Check if manifest exists
    if (Test-Path $manifestPath) {
        Write-Host "SECURITY: Verifying script integrity..." -ForegroundColor Cyan

        # Self-verify Orchestrator.ps1
        $selfPath = $MyInvocation.MyCommand.Definition
        $selfHash = (Get-FileHash -Path $selfPath -Algorithm SHA256).Hash
        $manifest = Get-Content $manifestPath -Raw | ConvertFrom-Json
        $expectedSelfHash = $manifest.scripts.'Orchestrator.ps1'

        if ($selfHash -ne $expectedSelfHash -and -not [string]::IsNullOrEmpty($expectedSelfHash)) {
            Write-Host "SECURITY ERROR: Orchestrator.ps1 integrity check failed!" -ForegroundColor Red
            Write-Host "  Expected: $expectedSelfHash" -ForegroundColor Red
            Write-Host "  Actual:   $selfHash" -ForegroundColor Red
            Write-Host "Script execution halted. This may indicate tampering." -ForegroundColor Red
            exit 1
        }
        Write-Host "SECURITY: Orchestrator.ps1 verified" -ForegroundColor Green
    }
    else {
        Write-Host "SECURITY WARNING: Hash manifest not found at $manifestPath" -ForegroundColor Yellow
        Write-Host "Proceeding without integrity verification" -ForegroundColor Yellow
    }
}
```

**Modify the script execution loop to verify each script:**
In the `foreach ($script in $scriptList)` loop, after checking if script exists:
```powershell
# Verify script integrity before execution
if ($verifyIntegrity -and (Test-Path $manifestPath)) {
    $scriptHash = (Get-FileHash -Path $scriptFile -Algorithm SHA256).Hash
    $expectedHash = $manifest.scripts.$script

    if (-not [string]::IsNullOrEmpty($expectedHash) -and $scriptHash -ne $expectedHash) {
        Write-Host "SECURITY ERROR: $script integrity check failed!" -ForegroundColor Red
        Write-Host "  Expected: $expectedHash" -ForegroundColor Red
        Write-Host "  Actual:   $scriptHash" -ForegroundColor Red
        Write-Host "Skipping execution of $script" -ForegroundColor Red
        continue  # Skip this script but continue with others
    }
    elseif (-not [string]::IsNullOrEmpty($expectedHash)) {
        Write-Host "SECURITY: $script verified" -ForegroundColor Green
    }
}
```

**Add verification for special scripts** (Invoke-AppsScript.ps1, Run-DiskCleanup.ps1, Run-Sysprep.ps1):
Apply similar verification before their `& $scriptFile` calls.

WHY inline verification instead of calling FFU.Core function: Orchestrator.ps1 runs inside the VM where FFU.Core may not be available. Use inline Get-FileHash calls.
  </action>
  <verify>
Search Orchestrator.ps1 for "SECURITY" - should find integrity verification code.
Search Orchestrator.ps1 for "Get-FileHash" - should find hash calculation calls.
  </verify>
  <done>
Orchestrator.ps1 verifies all script hashes before execution, halting on self-verification failure.
  </done>
</task>

</tasks>

<verification>
1. Functions exist: `Get-Command Test-ScriptIntegrity, New-OrchestrationHashManifest, Update-OrchestrationHashManifest -Module FFU.Core`
2. Manifest exists: `Test-Path FFUDevelopment/.security/orchestration-hashes.json`
3. Manifest valid: Contains SHA256 hashes for 6 scripts
4. Orchestrator.ps1 verifies integrity: Contains Get-FileHash and SECURITY checks
5. Module version bumped in FFU.Core.psd1
</verification>

<success_criteria>
- Three integrity verification functions implemented in FFU.Core
- Hash manifest generated for all 6 orchestration scripts
- Orchestrator.ps1 verifies script integrity before execution
- Self-verification failure halts Orchestrator.ps1
- Individual script verification failure skips script but continues
- Verification can be disabled via $verifyIntegrity flag
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-hardening/03-03-SUMMARY.md`
</output>
