---
phase: 03-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - FFUDevelopment/Modules/FFU.VM/FFU.VM.psm1
  - FFUDevelopment/BuildFFUVM.ps1
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FFU capture user password is generated as SecureString via New-SecureRandomPassword"
    - "Password remains as SecureString until final script injection point"
    - "BSTR cleanup happens immediately after plaintext conversion"
    - "No plaintext password variables persist beyond immediate use scope"
  artifacts:
    - path: "FFUDevelopment/Modules/FFU.VM/FFU.VM.psm1"
      provides: "SecureString-consistent credential handling"
      exports: ["Set-CaptureFFU", "Update-CaptureFFUScript"]
    - path: "FFUDevelopment/BuildFFUVM.ps1"
      provides: "SecureString password generation and flow"
  key_links:
    - from: "BuildFFUVM.ps1"
      to: "FFU.VM.psm1:Set-CaptureFFU"
      via: "Password parameter (SecureString)"
      pattern: "Set-CaptureFFU.*-Password"
    - from: "FFU.VM.psm1:Update-CaptureFFUScript"
      to: "WinPECaptureFFUFiles/CaptureFFU.ps1"
      via: "Script injection (plaintext required)"
      pattern: "SecureStringToBSTR.*PtrToStringBSTR"
---

<objective>
Audit and harden SecureString handling for FFU capture user password (SEC-02).

Purpose: The research shows the codebase has excellent SecureString foundations via New-SecureRandomPassword. This plan audits the complete password flow from generation to script injection, ensuring no gaps exist where plaintext persists longer than necessary.

Output: Verified secure password flow with any identified gaps closed.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-hardening/03-RESEARCH.md

# Source files
@FFUDevelopment/Modules/FFU.VM/FFU.VM.psm1
@FFUDevelopment/BuildFFUVM.ps1
@FFUDevelopment/Modules/FFU.Core/FFU.Core.psm1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit password flow in BuildFFUVM.ps1</name>
  <files>FFUDevelopment/BuildFFUVM.ps1</files>
  <action>
Search and audit all password-related code in BuildFFUVM.ps1:

1. Find where password is generated:
   - Look for `New-SecureRandomPassword` calls
   - Verify password is assigned to a variable typed as SecureString (not converted to string)

2. Find where password is passed to functions:
   - Look for `Set-CaptureFFU` calls - verify -Password receives SecureString
   - Look for `Update-CaptureFFUScript` calls - verify -Password receives SecureString

3. Find any plaintext conversion points:
   - Search for `SecureStringToBSTR`, `PtrToStringBSTR`, `PtrToStringAuto`
   - Search for `ConvertFrom-SecureString`
   - If found in BuildFFUVM.ps1, verify they're in tight try/finally with ZeroFreeBSTR cleanup

4. Document findings:
   - If flow is already secure, add comments confirming the security pattern
   - If gaps found, fix them by:
     a. Moving plaintext conversion to the last possible moment
     b. Adding proper BSTR cleanup in finally blocks
     c. Setting plaintext variables to $null after use
     d. Calling [GC]::Collect() after clearing (optional, for defense in depth)

Expected: The existing codebase likely already handles this well. Task is verification + documentation.
  </action>
  <verify>
Search for plaintext password variables: `Select-String -Pattern '\$plainPassword|\$plainTextPassword|\$passwordString' -Path FFUDevelopment/BuildFFUVM.ps1`
Should find 0 occurrences OR only in tight cleanup scopes.
  </verify>
  <done>
BuildFFUVM.ps1 password flow audited. No plaintext leaks outside controlled scopes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify and harden FFU.VM.psm1 credential functions</name>
  <files>FFUDevelopment/Modules/FFU.VM/FFU.VM.psm1</files>
  <action>
Audit the three credential-related functions in FFU.VM.psm1:

**1. Set-CaptureFFU (lines ~1179-1311):**
- Verify -Password parameter accepts [SecureString] (currently does)
- Verify password is passed as SecureString to New-LocalUserAccount and Set-LocalUserPassword
- Verify no plaintext conversion occurs in this function (it shouldn't need to)

**2. Update-CaptureFFUScript (lines ~1482-1659):**
- This function MUST convert SecureString to plaintext for script injection
- Verify the conversion pattern follows secure practices:
  ```powershell
  $bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password)
  try {
      $plainPassword = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)
      # Use plainPassword for script injection
  }
  finally {
      [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr)
      $plainPassword = $null
  }
  ```
- If the pattern is different, update to match this secure pattern
- Add comment explaining WHY plaintext is required here (WinPE cannot use SecureString)

**3. New-LocalUserAccount (lines ~73-152):**
- Already has proper BSTR cleanup in finally block (verified in research)
- Add SECURITY comment if not present documenting the pattern

**4. Set-LocalUserPassword (lines ~202-272):**
- Already has proper BSTR cleanup in finally block (verified in research)
- Add SECURITY comment if not present documenting the pattern

Add security comments to document the credential flow:
```powershell
# SECURITY: Password handling follows these principles:
# 1. Generated via New-SecureRandomPassword (never plaintext)
# 2. Passed as SecureString through all layers
# 3. Converted to plaintext ONLY at point of use (API calls, script injection)
# 4. BSTR immediately cleaned via ZeroFreeBSTR in finally block
# 5. Plaintext variable nulled immediately after use
```
  </action>
  <verify>
Search for BSTR cleanup: `Select-String -Pattern 'ZeroFreeBSTR' -Path FFUDevelopment/Modules/FFU.VM/FFU.VM.psm1`
Should find cleanup in all functions that convert SecureString.
  </verify>
  <done>
FFU.VM.psm1 credential functions verified secure. BSTR cleanup present in all conversion points.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Pester tests for SecureString handling</name>
  <files>Tests/Unit/FFU.VM.SecureString.Tests.ps1</files>
  <action>
Create new test file `Tests/Unit/FFU.VM.SecureString.Tests.ps1`:

```powershell
BeforeAll {
    # Import the module
    $modulePath = Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.VM\FFU.VM.psm1"

    # Mock dependencies
    Mock WriteLog {}
    Mock New-SecureRandomPassword {
        $securePassword = New-Object System.Security.SecureString
        "TestP@ssw0rd!".ToCharArray() | ForEach-Object { $securePassword.AppendChar($_) }
        $securePassword.MakeReadOnly()
        return $securePassword
    }

    Import-Module $modulePath -Force
}

Describe "FFU.VM SecureString Handling" {

    Context "Parameter Type Validation" {
        It "Set-CaptureFFU accepts SecureString for Password parameter" {
            $cmd = Get-Command Set-CaptureFFU
            $param = $cmd.Parameters['Password']
            $param.ParameterType.Name | Should -Be 'SecureString'
        }

        It "Update-CaptureFFUScript accepts SecureString for Password parameter" {
            $cmd = Get-Command Update-CaptureFFUScript
            $param = $cmd.Parameters['Password']
            # May accept object type to allow both string and SecureString
            # Verify it handles SecureString correctly
            $param | Should -Not -BeNullOrEmpty
        }

        It "New-LocalUserAccount accepts SecureString for Password parameter" {
            $cmd = Get-Command New-LocalUserAccount
            $param = $cmd.Parameters['Password']
            $param.ParameterType.Name | Should -Be 'SecureString'
        }

        It "Set-LocalUserPassword accepts SecureString for Password parameter" {
            $cmd = Get-Command Set-LocalUserPassword
            $param = $cmd.Parameters['Password']
            $param.ParameterType.Name | Should -Be 'SecureString'
        }
    }

    Context "BSTR Cleanup Pattern Verification" {
        It "New-LocalUserAccount source contains ZeroFreeBSTR cleanup" {
            $modulePath = Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.VM\FFU.VM.psm1"
            $content = Get-Content $modulePath -Raw

            # Find New-LocalUserAccount function
            $functionMatch = [regex]::Match($content, 'function New-LocalUserAccount[\s\S]*?(?=function|Export-ModuleMember|$)')
            $functionContent = $functionMatch.Value

            $functionContent | Should -Match 'SecureStringToBSTR'
            $functionContent | Should -Match 'ZeroFreeBSTR'
            $functionContent | Should -Match 'finally'
        }

        It "Set-LocalUserPassword source contains ZeroFreeBSTR cleanup" {
            $modulePath = Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.VM\FFU.VM.psm1"
            $content = Get-Content $modulePath -Raw

            # Find Set-LocalUserPassword function
            $functionMatch = [regex]::Match($content, 'function Set-LocalUserPassword[\s\S]*?(?=function|Export-ModuleMember|$)')
            $functionContent = $functionMatch.Value

            $functionContent | Should -Match 'SecureStringToBSTR'
            $functionContent | Should -Match 'ZeroFreeBSTR'
            $functionContent | Should -Match 'finally'
        }

        It "Update-CaptureFFUScript source contains ZeroFreeBSTR cleanup" {
            $modulePath = Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.VM\FFU.VM.psm1"
            $content = Get-Content $modulePath -Raw

            # Find Update-CaptureFFUScript function
            $functionMatch = [regex]::Match($content, 'function Update-CaptureFFUScript[\s\S]*?(?=function|Export-ModuleMember|$)')
            $functionContent = $functionMatch.Value

            $functionContent | Should -Match 'SecureStringToBSTR'
            $functionContent | Should -Match 'ZeroFreeBSTR'
            $functionContent | Should -Match 'finally'
        }
    }

    Context "No Plaintext Leaks" {
        It "FFU.VM.psm1 does not contain ConvertFrom-SecureString (DPAPI-based plaintext export)" {
            $modulePath = Join-Path $PSScriptRoot "..\..\FFUDevelopment\Modules\FFU.VM\FFU.VM.psm1"
            $content = Get-Content $modulePath -Raw

            # ConvertFrom-SecureString returns DPAPI-encrypted string, not good for cross-machine use
            # Should use SecureStringToBSTR pattern instead
            $content | Should -Not -Match 'ConvertFrom-SecureString\s+-Key'
        }
    }
}
```

Note: These tests verify the SOURCE CODE contains proper patterns rather than runtime behavior,
because testing actual SecureString behavior in memory is complex and unreliable.
  </action>
  <verify>
Invoke-Pester -Path "Tests/Unit/FFU.VM.SecureString.Tests.ps1" -Output Detailed
All tests should pass.
  </verify>
  <done>
Pester tests verify SecureString parameter types and BSTR cleanup patterns in source code.
  </done>
</task>

</tasks>

<verification>
1. Code audit: No plaintext password variables found outside tight cleanup scopes
2. BSTR cleanup: ZeroFreeBSTR called in finally blocks for all SecureString conversions
3. Parameter types: All password parameters accept SecureString
4. Pester tests pass: All new tests validate secure patterns
5. No regressions: Existing FFU.VM tests still pass
</verification>

<success_criteria>
- BuildFFUVM.ps1 password flow audited with no plaintext leaks
- FFU.VM.psm1 credential functions verified secure
- SECURITY comments document the credential flow pattern
- All functions use BSTR cleanup in finally blocks
- Pester tests validate secure patterns
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-hardening/03-02-SUMMARY.md`
</output>
